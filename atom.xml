<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ArtZoick.github.io/</id>
    <title>清汤牛肉锅</title>
    <updated>2019-07-22T13:55:40.891Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ArtZoick.github.io/"/>
    <link rel="self" href="https://ArtZoick.github.io//atom.xml"/>
    <subtitle>温故而知新
</subtitle>
    <logo>https://ArtZoick.github.io//images/avatar.png</logo>
    <icon>https://ArtZoick.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, 清汤牛肉锅</rights>
    <entry>
        <title type="html"><![CDATA[SpringMVC_1 入门、参数绑定、常用注解]]></title>
        <id>https://ArtZoick.github.io//post/springmvc_1</id>
        <link href="https://ArtZoick.github.io//post/springmvc_1">
        </link>
        <updated>2019-07-22T10:23:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-三层架构和mvc">一、三层架构和MVC</h2>
<h3 id="三层架构">三层架构</h3>
<p>1、开发服务器端程序，一般都基于两种形式，一种C/S架构（客户端/服务器）程序，一种B/S架构（浏览器/服务器）程序</p>
<p>2、使用Java语言基本上都是开发B/S架构的程序，B/S架构又分成了三层架构</p>
<p>3、三层架构<br>
　　表现层：WEB层，用来和客户端进行数据交互的。表现层一般会采用MVC的设计模型<br>
　　业务层：处理具体的业务逻辑的<br>
　　持久层：用来操作数据库的</p>
<h3 id="mvc模型">MVC模型</h3>
<p>1、MVC全名是Model View Controller 模型视图控制器，每个部分各司其职。<br>
2、Model：数据模型，JavaBean的类，用来进行数据封装。<br>
3、View：指JSP、HTML用来展示数据给用户<br>
4、Controller：用来接收用户的请求，整个流程的控制器。用来进行数据校验等。</p>
<h2 id="二-springmvc的入门案例">二、SpringMVC的入门案例</h2>
<h3 id="基本框架如下">基本框架如下：</h3>
<p><img src="https://ArtZoick.github.io//post-images/springmvc/1.png" alt=""></p>
<h3 id="1-web工程pom导入坐标">1、WEB工程，pom导入坐标</h3>
<pre><code class="language-xml">&lt;!-- 版本锁定 --&gt;
&lt;properties&gt;
&lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt;
&lt;/properties&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
      &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
      &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
      &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
      &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
      &lt;version&gt;2.5&lt;/version&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
      &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
      &lt;version&gt;2.0&lt;/version&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
</code></pre>
<h3 id="2-webxml中的配置">2、web.xml中的配置</h3>
<pre><code class="language-xml">&lt;servlet&gt;
    &lt;!--配置前端控制器--&gt;
    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    
    &lt;!--加载springmvc.xml配置文件--&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
      &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    
    &lt;!--启动服务器即可创建--&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;/servlet&gt;
  
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
</code></pre>
<p><strong>其中相关配置说明：</strong><br>
servlet标签中<br>
1、配置前端控制器DispatcherServlet 。<br>
2、servlet加载全局初始化参数springmvc.xml，继而springmvc.xml中的配置能生效。<br>
3、启动服务器即可使servlet标签中的配置生效：创建DispatcherServlet对象，加载springmvc.xml配置文件。</p>
<p>servlet-mapping标签中<br>
1、使servlet标签中内容被请求到。<br>
2、url-pattern中/是，让所有请求都被serlvet拦截到，继而走前端控制器。</p>
<h3 id="3-springmvcxml配置">3、springmvc.xml配置</h3>
<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;
http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/mvc
http://www.springframework.org/schema/mvc/spring-mvc.xsd
http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;


    &lt;!--开启注解扫描--&gt;
    &lt;context:component-scan base-package=&quot;top.zoick&quot;/&gt;
    &lt;!--配置视图解析器对象--&gt;
    &lt;bean id=&quot;internalResourceViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

    &lt;!--开启SpringMVC框架注解支持--&gt;
    &lt;mvc:annotation-driven/&gt;
&lt;/beans&gt;
</code></pre>
<p><strong>其中相关配置说明：</strong><br>
1、component-scan开启注解扫描，使spring能识别类中的@Controller等注解，将类交给IOC容器来管理。<br>
2、配置视图解析器InternalResourceViewResolver，Controller中有return的值，如&quot;success&quot;。即为返回success.jsp这个页面。也需要使用配置来使springmvc框架知道在哪儿。这里需要使用<property>标签配置前缀和后缀。<br>
3、开启springmvc框架注解支持，使springmvc相关注解能被支持。</p>
<p><strong>&lt;mvc: annotation-driven/&gt;说明：</strong><br>
在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。<br>
使 用 &lt;mvc: annotation-driven&gt; 自 动加载 RequestMappingHandlerMapping （处理映射器） 和<br>
RequestMappingHandlerAdapter （ 处 理 适 配 器 ） ， 可 用 在 SpringMVC.xml 配 置 文 件 中 使 用<br>
&lt;mvc: annotation-driven&gt;替代注解处理器和适配器的配置。</p>
<h3 id="4-编写indexjsp和hellocontroller控制器类-启动tomcat">4、编写index.jsp和HelloController控制器类、启动Tomcat</h3>
<p><em>index.jsp</em></p>
<pre><code class="language-jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h3&gt;入门程序&lt;/h3&gt;

&lt;a href=&quot;hello&quot;&gt;入门程序&lt;/a&gt;
&lt;a href=&quot;hello&quot;&gt;测试RequsetMapping&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<p><em>HelloController</em></p>
<pre><code class="language-java">package top.zoick.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
@RequestMapping(path = &quot;user&quot;)
public class HelloController {

    /**
     * 入门案例
     *
     * @return
     */
    @RequestMapping(path = &quot;/hello&quot;)
    public String sayHello() {
        System.out.println(&quot;Hello StringMVC&quot;);
        return &quot;success&quot;;
    }

    /**
     * RequestMapping注解
     *
     * @return
     */
    @RequestMapping(path = &quot;testRequestMapping&quot;)
    public String testRequestMapping() {
        System.out.println(&quot;测试RequsetMapping&quot;);
        return &quot;success&quot;;
    }
}

</code></pre>
<p><strong>在WEB-INF目录下创建pages文件夹，编写success.jsp的成功页面</strong></p>
<pre><code class="language-jsp">&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h3&gt;入门成功&lt;/h3&gt;
    
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>部署到Tomcat服务器上，进行测试即可。</strong></p>
<h3 id="入门案例的执行过程分析">入门案例的执行过程分析</h3>
<p><img src="https://ArtZoick.github.io//post-images/springmvc/2.bmp" alt=""></p>
<p><strong>1、入门案例的执行流程</strong></p>
<p>1、当启动Tomcat服务器的时候，因为配置了load-on-startup标签，所以会创建DispatcherServlet对象，<br>
就会加载springmvc.xml配置文件<br>
2、开启了注解扫描，那么HelloController对象就会被创建。<br>
3、从index.jsp发送请求，请求会先到达DispatcherServlet核心控制器，根据配置@RequestMapping注解<br>
找到执行的具体方法。<br>
4、根据执行方法的返回值，再根据配置的视图解析器，去指定的目录下查找指定名称的JSP文件。<br>
5、Tomcat服务器渲染页面，做出响应。</p>
<p><strong>2、SpringMVC官方提供图形</strong></p>
<p><img src="https://ArtZoick.github.io//post-images/springmvc/3.bmp" alt=""></p>
<p><strong>3、入门案例中的组件分析</strong></p>
<ol>
<li>前端控制器（DispatcherServlet）：用户请求到达前端控制器，它就相当于 mvc 模式中的 c，dispatcherServlet 是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet 的存在降低了组件之间的耦合性。</li>
<li>处理器映射器（HandlerMapping）：HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</li>
<li>处理器（Handler）：它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由Handler 对具体的用户请求进行处理。</li>
<li>处理器适配器（HandlAdapter）：通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</li>
<li>视图解析器（View Resolver）：View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。</li>
<li>视图（View）：一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户</li>
</ol>
<h3 id="requestmapping注解">RequestMapping注解</h3>
<p><strong>1、RequestMapping注解的作用是建立请求URL和处理方法之间的对应关系</strong></p>
<p><strong>2、RequestMapping注解可以作用在方法和类上</strong><br>
　　作用在类上：第一级的访问目录<br>
　　作用在方法上：第二级的访问目录<br>
　　细节：路径可以不编写 / 表示应用的根目录开始<br>
　　细节：${ pageContext.request.contextPath }也可以省略不写，但是路径上不能写 /</p>
<p><strong>3、RequestMapping的属性</strong><br>
　　path 指定请求路径的url<br>
　　value value属性和path属性是一样的<br>
　　method 指定该方法的请求方式<br>
　　params 指定限制请求参数的条件<br>
　　headers 发送的请求中必须包含的请求头</p>
<h2 id="三-请求参数的绑定">三、请求参数的绑定</h2>
<h3 id="1-请求参数的绑定说明">1、请求参数的绑定说明</h3>
<p>1、绑定机制<br>
　　　　1、表单提交的数据都是k=v格式的 username=haha&amp;password=123<br>
　　　　2、SpringMVC的参数绑定过程是把表单提交的请求参数，作为控制器中方法的参数进行绑定的<br>
　　　　3、要求：提交表单的name和参数的名称是相同的</p>
<p>2、支持的数据类型<br>
　　　　基本数据类型和字符串类型<br>
　　　　实体类型（JavaBean）<br>
　　　　集合数据类型（List、map集合等）</p>
<h3 id="2-绑定的注意事项">2、绑定的注意事项</h3>
<p>1、基本数据类型和字符串类型<br>
　　　　提交表单的name和参数的名称是相同的<br>
　　　　区分大小写<br>
　　2、实体类型（JavaBean）<br>
　　　　提交表单的name和JavaBean中的属性名称需要一致<br>
　　　　如果一个JavaBean类中包含其他的引用类型，那么表单的name属性需要编写成：对象.属性 例如：address.name</p>
<p>3、给集合属性数据封装<br>
　　　　JSP页面编写方式：list[0].属性</p>
<h3 id="3-请求参数中文乱码的解决">3、请求参数中文乱码的解决</h3>
<p>在web.xml中配置Spring提供的过滤器类</p>
<pre><code class="language-xml"> &lt;!--配置解决中文乱码的过滤器--&gt;
  &lt;filter&gt;
    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;!--指定UTF-8字符集--&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;encoding&lt;/param-name&gt;
      &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
  &lt;/filter&gt;
  &lt;filter-mapping&gt;
    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;
</code></pre>
<h3 id="4-自定义类型转换器">4、自定义类型转换器</h3>
<p>1、表单提交的任何数据类型全部都是字符串类型，但是后台定义Integer类型，数据也可以封装上，说明<br>
Spring框架内部会默认进行数据类型转换。</p>
<p>2、如果想自定义数据类型转换，可以实现<strong>Converter</strong>的接口<br>
　　1、自定义类型转换器</p>
<pre><code class="language-java">public class StringToDateConverter implements Converter&lt;String, Date&gt; {
    /**
     * String source 传进来的字符串
     * @param source
     * @return
     */
    @Override
    public Date convert(String source) {
        //判断
        if(source==null){
            throw new RuntimeException(&quot;请传入数据&quot;);
        }
        DateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);

        try {
            return df.parse(source);
        } catch (ParseException e) {
            throw new RuntimeException(&quot;数据类型转换出现错误&quot;);
        }
    }
}

</code></pre>
<p>2、注册自定义类型转换器，在springmvc.xml配置文件中编写配置</p>
<pre><code class="language-xml"> &lt;!--配置自定义类型转换器--&gt;
    &lt;bean id=&quot;ConversionService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt;
        &lt;!--将自己写的类型转换器配置进去--&gt;
        &lt;property name=&quot;converters&quot;&gt;
            &lt;set&gt;
                &lt;bean class=&quot;top.zoick.utils.StringToDateConverter&quot;/&gt;
            &lt;/set&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;!--开启SpringMVC框架注解支持--&gt;
    &lt;!--conversion-service  将类型转换器配置生效 --&gt;
    &lt;mvc:annotation-driven conversion-service=&quot;ConversionService&quot;/&gt;
</code></pre>
<h3 id="5-在控制器中使用原生的servletapi对象">5、在控制器中使用原生的ServletAPI对象</h3>
<p>只需要在控制器的方法参数定义HttpServletRequest和HttpServletResponse对象</p>
<h3 id="6-controller中和jsp中的代码">6、controller中和jsp中的代码</h3>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;/param&quot;)
public class ParamController {

    /**
     * 请求参数绑定入门
     * @param username
     * @return
     */
    @RequestMapping(&quot;testParam&quot;)
    public String testparam(String username){
        System.out.println(&quot;执行了...&quot;);
        System.out.println(&quot;用户名：&quot;+username);
        return &quot;success&quot;;
    }

    /**
     * 请求参数绑定，把数据封装到javaBean的类当中
     * @return
     */
    @RequestMapping(&quot;saveAccount&quot;)
    public String saveAccount(Account account){
        System.out.println(&quot;执行了...&quot;);
        System.out.println(account);
        return &quot;success&quot;;
    }

    /**
     * 自定义类型转换器
     * @param user
     * @return
     */
    @RequestMapping(&quot;/saveUser&quot;)
    public String saveUser(User user){
        System.out.println(&quot;执行了...&quot;);
        System.out.println(user);
        return &quot;success&quot;;
    }

    /**
     * 原生的api获取
     * @return
     */
    @RequestMapping(&quot;testServlet&quot;)
    public String testServlet(HttpServletRequest request, HttpServletResponse response){
        System.out.println(&quot;执行了...&quot;);
        System.out.println(request);
        HttpSession session = request.getSession();
        System.out.println(session);
        ServletContext servletContext = session.getServletContext();
        System.out.println(servletContext);
        System.out.println(response);
        return &quot;success&quot;;
    }
}
</code></pre>
<pre><code class="language-jsp">&lt;%--请求参数绑定--%&gt;
&lt;a href=&quot;param/testParam?username=hehe&amp;password=123&quot;&gt;请求参数绑定&lt;/a&gt;

&lt;%--把数据封装Account类中
  每个input里的name和javabean的属性名相同--%&gt;
&lt;form action=&quot;param/saveAccount&quot; method=&quot;post&quot;&gt;
    姓名：&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;br/&gt;
    密码：&lt;input type=&quot;text&quot; name=&quot;password&quot;/&gt;&lt;br/&gt;
    金额：&lt;input type=&quot;text&quot; name=&quot;money&quot;/&gt;&lt;br/&gt;
    &lt;!--Account类中引用类型的封装，name标签中，user表示是account中的User user，后面.uname表示是user中的属性--&gt;
    用户姓名：&lt;input type=&quot;text&quot; name=&quot;user.uname&quot;/&gt;&lt;br/&gt;
    用户年龄：&lt;input type=&quot;text&quot; name=&quot;user.age&quot;/&gt;&lt;br/&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;
&lt;/form&gt;

&lt;%--把数据封装Account类中，类中存在list和map的集合 --%&gt;
&lt;form action=&quot;param/saveAccount&quot; method=&quot;post&quot;&gt;
    姓名：&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;br/&gt;
    密码：&lt;input type=&quot;text&quot; name=&quot;password&quot;/&gt;&lt;br/&gt;
    金额：&lt;input type=&quot;text&quot; name=&quot;money&quot;/&gt;&lt;br/&gt;

    &lt;%--把uname和age都封装到User对象中去，然后再存到list中去--%&gt;
    用户姓名：&lt;input type=&quot;text&quot; name=&quot;list[0].uname&quot;/&gt;&lt;br/&gt;
    用户年龄：&lt;input type=&quot;text&quot; name=&quot;list[0].age&quot;/&gt;&lt;br/&gt;

    &lt;%--map['one']里的one为key值，随便写的，但要符合定义时的key值 String。
    同样，这里将uname和age都封装到User对对象中，再存入map集合。map的key值为one--%&gt;
    用户姓名：&lt;input type=&quot;text&quot; name=&quot;map['one'].uname&quot;/&gt;&lt;br/&gt;
    用户年龄：&lt;input type=&quot;text&quot; name=&quot;map['one'].age&quot;/&gt;&lt;br/&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;
&lt;/form&gt;

&lt;%--自定义类型转换器--%&gt;
&lt;form action=&quot;param/saveUser&quot; method=&quot;post&quot;&gt;
    用户姓名：&lt;input type=&quot;text&quot; name=&quot;uname&quot;/&gt;&lt;br/&gt;
    用户年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;/&gt;&lt;br/&gt;
    用户生日：&lt;input type=&quot;text&quot; name=&quot;date&quot;/&gt;&lt;br/&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;
&lt;/form&gt;

&lt;a href=&quot;param/testServlet&quot;&gt;Servlet原生的API&lt;/a&gt;&lt;br/&gt;
</code></pre>
<h2 id="四-常用的注解">四、常用的注解</h2>
<h3 id="1-requestparam注解">1、RequestParam注解</h3>
<p><strong>作用:</strong> 把请求中的指定名称的参数传递给控制器中的形参赋值</p>
<p><strong>属性:</strong><br>
value：请求参数中的名称<br>
required：请求参数中是否必须提供此参数，默认值是true，必须提供</p>
<p><strong>代码：</strong></p>
<pre><code class="language-java">@RequestMapping(&quot;/testRequestParam&quot;)
    public String testRequestParam(@RequestParam(value = &quot;username&quot;) String name) {
        System.out.println(&quot;执行了...&quot;);
        System.out.println(name);
        return &quot;success&quot;;
    }
</code></pre>
<pre><code class="language-jsp">&lt;a href=&quot;anno/testRequestParam?username=hehe&quot;&gt;testRequestParam&lt;/a&gt;
</code></pre>
<h3 id="2-requestbody注解">2、RequestBody注解</h3>
<p><strong>作用:</strong> 用于获取请求体的内容（注意：get方法不可以）</p>
<p>**属性: **<br>
required：是否必须有请求体，默认值是true</p>
<p><strong>代码:</strong></p>
<pre><code class="language-java">/**
     * 获取请求体的内容
     * @param body
     * @return
     */
    @RequestMapping(&quot;/testRequestBody&quot;)
    public String testRequestBody(@RequestBody String body) {
        System.out.println(&quot;执行了...&quot;);
        System.out.println(body);
        return &quot;success&quot;;
    }
</code></pre>
<pre><code class="language-jsp">&lt;form action=&quot;anno/testRequestBody&quot; method=&quot;post&quot;&gt;
    用户姓名：&lt;input type=&quot;text&quot; name=&quot;uname&quot;/&gt;&lt;br/&gt;
    用户年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;/&gt;&lt;br/&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;
&lt;/form&gt;
</code></pre>
<h3 id="3-pathvariable注解">3、PathVariable注解</h3>
<p><strong>作用:</strong> 拥有绑定url中的占位符的。例如：url中有/delete/{id}，{id}就是占位符</p>
<p><strong>属性：</strong><br>
value：指定url中的占位符名称</p>
<p><strong>Restful风格的URL</strong></p>
<p>1、请求路径一样，可以根据不同的请求方式去执行后台的不同方法</p>
<p>2、restful风格的URL优点<br>
　　　　结构清晰<br>
　　　　符合标准<br>
　　　　易于理解<br>
　　　　扩展方便</p>
<p><strong>代码：</strong></p>
<pre><code class="language-java">/**
     * PathVariable注解
     *
     * @param id
     * @return
     */
    @RequestMapping(&quot;/testPathVariable/{sssssid}&quot;)
    public String testPathVariable(@PathVariable(name = &quot;sssssid&quot;) String id) {
        System.out.println(&quot;执行了...&quot;);
        System.out.println(id);
        return &quot;success&quot;;
    }
</code></pre>
<pre><code class="language-jsp">&lt;a href=&quot;anno/testPathVariable/10&quot;&gt;testPathVariable&lt;/a&gt;
</code></pre>
<h3 id="4-requestheader注解">4、RequestHeader注解</h3>
<p><strong>作用:</strong> 获取指定请求头的值</p>
<p><strong>属性：</strong><br>
value：请求头的名称</p>
<p><strong>代码：</strong></p>
<pre><code class="language-java"> /**
     * 获取请求头的值
     *
     * @param header
     * @return
     */
    @RequestMapping(&quot;/testRequestHeader&quot;)
    public String testRequestHeader(@RequestHeader(value = &quot;Accept&quot;) String header) {
        System.out.println(&quot;执行了...&quot;);
        System.out.println(header);
        return &quot;success&quot;;
    }
</code></pre>
<pre><code class="language-jsp">&lt;a href=&quot;anno/testRequestHeader&quot;&gt;RequestHeader&lt;/a&gt;&lt;br/&gt;
</code></pre>
<h3 id="5-cookievalue注解">5、CookieValue注解</h3>
<p><strong>作用:</strong> 用于获取指定cookie的名称的值</p>
<p><strong>属性：</strong><br>
value：cookie的名称</p>
<p><strong>代码:</strong></p>
<pre><code class="language-java">@RequestMapping(path=&quot;/hello&quot;)
public String sayHello(@CookieValue(value=&quot;JSESSIONID&quot;) String cookieValue) {
	System.out.println(cookieValue);
	return &quot;success&quot;;
}
</code></pre>
<h3 id="6-modelattribute注解">6、ModelAttribute注解</h3>
<p><strong>作用:</strong><br>
出现在方法上：表示当前方法会在控制器方法执行前线执行。<br>
出现在参数上：获取指定的数据给参数赋值。</p>
<p><strong>应用场景：</strong><br>
当提交表单数据不是完整的实体数据时，保证没有提交的字段使用数据库原来的数据。</p>
<p><strong>代码：</strong></p>
<p>1、修饰的方法有返回值</p>
<pre><code class="language-java"> /**
     * ModelAttribute注解
     *
     * @return
     */
    @RequestMapping(&quot;/testModelAttribute&quot;)
    public String testModelAttribute(User user) {
        System.out.println(&quot;执行了...&quot;);
        System.out.println(user);
        return &quot;success&quot;;
    }

    @ModelAttribute
    public User showUser(String uname) {
        System.out.println(&quot;showUser方法执行了...&quot;);
        //通过用户查询数据库(模拟）
        User user = new User();
        user.setUname(uname);
        user.setAge(12);
        user.setDate(new Date());
        return user;
    }
</code></pre>
<pre><code class="language-jsp">&lt;form action=&quot;anno/testModelAttribute&quot; method=&quot;post&quot;&gt;
    用户姓名：&lt;input type=&quot;text&quot; name=&quot;uname&quot;/&gt;&lt;br/&gt;
    用户年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;/&gt;&lt;br/&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;
&lt;/form&gt;
</code></pre>
<ol start="2">
<li>修饰的方法没有返回值</li>
</ol>
<pre><code class="language-java">/**
* 作用在方法，先执行
* @param name
* @return
*/
@ModelAttribute
public void showUser(String name,Map&lt;String, User&gt; map) {
System.out.println(&quot;showUser执行了...&quot;);
// 模拟从数据库中查询对象
User user = new User();
user.setName(&quot;哈哈&quot;);
user.setPassword(&quot;123&quot;);
user.setMoney(100d);
map.put(&quot;abc&quot;, user);
}
/**
* 修改用户的方法
* @param cookieValue
* @return
*/
@RequestMapping(path=&quot;/updateUser&quot;)
public String updateUser(@ModelAttribute(value=&quot;abc&quot;) User user) {
	System.out.println(user);
	return &quot;success&quot;;
}
</code></pre>
<h3 id="7-sessionattributes注解">7、SessionAttributes注解</h3>
<p><strong>作用:</strong> 用于多次执行控制器方法间的参数共享</p>
<p><strong>属性：</strong><br>
value：指定存入属性的名称</p>
<p><strong>代码：</strong></p>
<pre><code class="language-java">/**
     * SessionAttrubutes注解
     *
     * @return
     */
    @RequestMapping(&quot;/testSessionAttrubutes&quot;)
    public String testSessionAttrubutes(Model model) {
        System.out.println(&quot;执行了...&quot;);
        //底层会存储到request域对象中
        model.addAttribute(&quot;msg&quot;, &quot;zoick&quot;);
        return &quot;success&quot;;
    }

    /**
     * 获取值
     * @param modelmap
     * @return
     */
    @RequestMapping(&quot;/getSessionAttrubutes&quot;)
    public String getSessionAttrubutes(ModelMap modelmap) {
        System.out.println(&quot;getSessionAttrubutes...&quot;);
        String msg = (String) modelmap.get(&quot;msg&quot;);
        System.out.println(msg);
        return &quot;success&quot;;
    }

    @RequestMapping(&quot;/delSessionAttrubutes&quot;)
    public String delSessionAttrubutes(SessionStatus status) {
        System.out.println(&quot;delSessionAttrubutes...&quot;);
        status.setComplete();
        return &quot;success&quot;;
    }

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IntelliJ IDEA 快捷键]]></title>
        <id>https://ArtZoick.github.io//post/intellij_idea_shortcuts</id>
        <link href="https://ArtZoick.github.io//post/intellij_idea_shortcuts">
        </link>
        <updated>2019-07-15T07:00:21.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;mid=2247487161&amp;idx=1&amp;sn=790d7c7f77a78fd307ea0124cd167a3c&amp;chksm=fa24f1d1cd5378c7c3488cd0e5fb5285eac1a1d15a7e94b0fb5f0f04ae716cb3329452628330&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;key=0c05566442c631fc47a93564df35275d8492002c1773792ef2f593d5d6e160284d1aef52f03c55fc952ff0e2901ae609bf10ae612bb51fbff2c415b0361eea1edf8551811b52be46166a589db0c396fd&amp;ascene=1&amp;uin=MjU3MjY4MzYwMQ%3D%3D&amp;devicetype=Windows+10&amp;version=62060834&amp;lang=zh_CN&amp;pass_ticket=nKMxnj7FG6IE%2FDE7PG3CnhiQs6vjvkAd4q%2FmMR0xc6WD3wZ891aJh8iMnIqMNsVp">来源于公众号</a></p>
<h2 id="自动代码"><strong>▌自动代码</strong></h2>
<p>常用的有 fori/sout/psvm+Tab 即可生成循环、System.out、main 方法等 boilerplate 样板代码 。</p>
<p><strong>例如要输入 for(User user : users) 只需输入 user.for+Tab ；</strong></p>
<p><strong>再比如，要输入 Date birthday = user.getBirthday() 只需输入user.getBirthday().var+Tab 即可。</strong></p>
<p>代码标签输入完成后，按 Tab，生成代码。</p>
<ol>
<li>Ctrl+Alt+O 优化导入的类和包</li>
<li>Alt+Insert 生成代码(如 get,set 方法,构造函数等)   或者右键（Generate）</li>
<li>fori/sout/psvm + Tab</li>
<li>Ctrl+Alt+T  生成 try catch  或者 Alt+enter</li>
<li>CTRL+ALT+T  把选中的代码放在 TRY{} IF{} ELSE{} 里</li>
<li>Ctrl + O 重写方法</li>
<li>Ctrl + I 实现方法</li>
<li>Ctr+shift+U 大小写转化</li>
<li>ALT+回车    导入包,自动修正</li>
<li>ALT+/       代码提示</li>
<li>CTRL+J      自动代码</li>
<li>Ctrl+Shift+J，整合两行为一行</li>
<li>CTRL+空格   代码提示</li>
<li>CTRL+SHIFT+SPACE 自动补全代码</li>
<li>CTRL+ALT+L  格式化代码</li>
<li>CTRL+ALT+I  自动缩进</li>
<li>CTRL+ALT+O  优化导入的类和包</li>
<li>ALT+INSERT  生成代码(如 GET,SET 方法,构造函数等)</li>
<li>CTRL+E      最近更改的代码</li>
<li>CTRL+ALT+SPACE  类名或接口名提示</li>
<li>CTRL+P   方法参数提示</li>
<li>CTRL+Q，可以看到当前方法的声明</li>
<li>Shift+F6  重构-重命名 (包、类、方法、变量、甚至注释等)</li>
<li>Ctrl+Alt+V 提取变量</li>
</ol>
<h2 id="查询快捷键"><strong>▌查询快捷键</strong></h2>
<ol>
<li>Ctrl＋Shift＋Backspace 可以跳转到上次编辑的地</li>
<li>CTRL+ALT+ left/right 前后导航编辑过的地方</li>
<li>ALT+7  靠左窗口显示当前文件的结构</li>
<li>Ctrl+F12 浮动显示当前文件的结构</li>
<li>ALT+F7 找到你的函数或者变量或者类的所有引用到的地方</li>
<li>CTRL+ALT+F7  找到你的函数或者变量或者类的所有引用到的地方</li>
<li>Ctrl+Shift+Alt+N 查找类中的方法或变量</li>
<li>双击SHIFT 在项目的所有目录查找文件</li>
<li>Ctrl+N   查找类</li>
<li>Ctrl+Shift+N 查找文件</li>
<li>CTRL+G   定位行</li>
<li>CTRL+F   在当前窗口查找文本</li>
<li>CTRL+SHIFT+F  在指定窗口查找文本</li>
<li>CTRL+R   在 当前窗口替换文本</li>
<li>CTRL+SHIFT+R  在指定窗口替换文本</li>
<li>ALT+SHIFT+C  查找修改的文件</li>
<li>CTRL+E   最近打开的文件</li>
<li>F3   向下查找关键字出现位置</li>
<li>SHIFT+F3  向上一个关键字出现位置</li>
<li>选中文本，按Alt+F3 ，高亮相同文本，F3逐个往下查找相同文本</li>
<li>F4   查找变量来源</li>
<li>CTRL+SHIFT+O  弹出显示查找内容</li>
<li>Ctrl+W 选中代码，连续按会有其他效果</li>
<li>F2 或Shift+F2 高亮错误或警告快速定位</li>
<li>Ctrl+Up/Down 光标跳转到第一行或最后一行下</li>
<li>Ctrl+B 快速打开光标处的类或方法</li>
<li>CTRL+ALT+B  找所有的子类</li>
<li>CTRL+SHIFT+B  找变量的类</li>
<li>Ctrl+Shift+上下键  上下移动代码</li>
<li>Ctrl+Alt+ left/right 返回至上次浏览的位置</li>
<li>Ctrl+X 删除行</li>
<li>Ctrl+D 复制行</li>
<li>Ctrl+/ 或 Ctrl+Shift+/  注释（// 或者/<em>...</em>/ ）</li>
<li>Ctrl+H 显示类结构图</li>
<li>Ctrl+Q 显示注释文档</li>
<li>Alt+F1 查找代码所在位置</li>
<li>Alt+1 快速打开或隐藏工程面板</li>
<li>Alt+ left/right 切换代码视图</li>
<li>ALT+ ↑/↓  在方法间快速移动定位</li>
<li>CTRL+ALT+ left/right 前后导航编辑过的地方</li>
<li>Ctrl＋Shift＋Backspace可以跳转到上次编辑的地</li>
<li>Alt+6    查找TODO</li>
</ol>
<h2 id="其他快捷键"><strong>▌其他快捷键</strong></h2>
<ol>
<li>SHIFT+ENTER 另起一行</li>
<li>CTRL+Z   倒退(撤销)</li>
<li>CTRL+SHIFT+Z  向前(取消撤销)</li>
<li>CTRL+ALT+F12  资源管理器打开文件夹</li>
<li>ALT+F1   查找文件所在目录位置</li>
<li>SHIFT+ALT+INSERT 竖编辑模式</li>
<li>CTRL+F4  关闭当前窗口</li>
<li>Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义</li>
<li>Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单）</li>
</ol>
<h2 id="svn快捷键"><strong>▌svn快捷键</strong></h2>
<ol>
<li>ctrl+k 提交代码到SVN</li>
<li>ctrl+t 更新代码</li>
</ol>
<h2 id="调试快捷键"><strong>▌调试快捷键</strong></h2>
<p>其实常用的 就是 F8 F7 F9 最值得一提的就是 Drop Frame 可以让运行过的代码从头再来。</p>
<ol>
<li>alt+F8    debug 时选中查看值</li>
<li>Alt+Shift+F9，选择 Debug</li>
<li>Alt+Shift+F10，选择 Run</li>
<li>Ctrl+Shift+F9，编译</li>
<li>Ctrl+Shift+F8，查看断点</li>
<li>F7，步入</li>
<li>Shift+F7，智能步入</li>
<li>Alt+Shift+F7，强制步入</li>
<li>F8，步过</li>
<li>Shift+F8，步出</li>
<li>Alt+Shift+F8，强制步过</li>
<li>Alt+F9，运行至光标处</li>
<li>Ctrl+Alt+F9，强制运行至光标处</li>
<li>F9，恢复程序</li>
<li>Alt+F10，定位到断点</li>
</ol>
<h2 id="重构"><strong>▌重构</strong></h2>
<ol>
<li>Ctrl+Alt+Shift+T，弹出重构菜单</li>
<li>Shift+F6，重命名</li>
<li>F6，移动</li>
<li>F5，复制</li>
<li>Alt+Delete，安全删除</li>
<li>Ctrl+Alt+N，内联</li>
</ol>
<h2 id="十大intellij-idea快捷键"><strong>▌十大Intellij IDEA快捷键</strong></h2>
<p>Intellij IDEA 中有很多快捷键让人爱不释手，stackoverflow 上也有一些有趣的讨论。</p>
<p>每个人都有自己的最爱，想排出个理想的榜单还真是困难。</p>
<p>以前也整理过Intellij的快捷键，这次就按照我日常开发时的使用频率，简单分类列一下我最喜欢的十大快捷-神-键吧。</p>
<p><strong>1 智能提示:</strong></p>
<p>Intellij 首当其冲的当然就是 Intelligence 智能！</p>
<p>基本的代码提示用 Ctrl+Space，还有更智能地按类型信息提示  Ctrl+Shift+Space，但因为Intellij总是随着我们敲击而自动提示，所以很多时候都不会手动敲这两个快捷键(除非提示框消失了)。</p>
<p>用 F2/ Shift+F2 移动到有错误的代码，Alt+Enter 快速修复(即 Eclipse中的 Quick Fix 功能)。</p>
<p>当智能提示为我们自动补全方法名时，我们通常要自己补上行尾的反括号和分号，当括号嵌套很多层时会很麻烦，这时我们只需敲 Ctrl+Shift+Enter 就能自动补全末尾的字符。</p>
<p>而且不只是括号，例如敲完 if/for 时也可以自动补上 {} 花括号。</p>
<p>最后要说一点，Intellij 能够智能感知 Spring、Hibernate 等主流框架的配置文件和类，以静制动，在看似“静态”的外表下，智能地扫描理解你的项目是如何构造和配置的。</p>
<p><strong>2 重构:</strong></p>
<p>Intellij 重构是另一完爆 Eclipse 的功能，其智能程度令人瞠目结舌，比如提取变量时自动检查到所有匹配同时提取成一个变量等。</p>
<p>尤其看过《重构-改善既有代码设计》之后，有了 Intellij 的配合简直是令人大呼过瘾！也正是强大的智能和重构功能，使 Intellij 下的 TDD 开发非常顺畅。</p>
<p>切入正题，先说一个无敌的重构功能大汇总快捷键 Ctrl+Shift+Alt+T，叫做 Refactor This。</p>
<p>按法有点复杂，但也符合 Intellij 的风格，很多快捷键都要双手完成，而不像 Eclipse 不少最有用的快捷键可以潇洒地单手完成(不知道算不算 Eclipse 的一大优点)，但各位用过 Emacs 的话就会觉得也没什么了(非 Emacs 黑)。</p>
<p>此外，还有些最常用的重构技巧，因为太常用了，若每次都在Refactor This 菜单里选的话效率有些低。</p>
<p>比如 Shift+F6 直接就是改名，Ctrl+Alt+V 则是提取变量。</p>
<p><strong>3 代码生成：</strong></p>
<p>这一点类似 Eclipse，虽不是独到之处，但因为日常使用频率极高，所以还是罗列在榜单前面。</p>
<p>常用的有 fori/sout/psvm+Tab 即可生成循环、System.out、main 方法等 boilerplate 样板代码，用 Ctrl+J可 以查看所有模板。</p>
<p>后面“辅助”一节中将会讲到 Alt+Insert，在编辑窗口中点击可以生成构造函数、toString、getter/setter、重写父类方法等。</p>
<p>这两个技巧实在太常用了，几乎每天都要生成一堆 main、System.out 和 getter/setter。</p>
<p>另外，Intellij IDEA 13 中加入了后缀自动补全功能( Postfix Completion)，比模板生成更加灵活和强大。</p>
<p>例如要输入 for(User user : users) 只需输入 user.for+Tab。</p>
<p>再比如，要输入 Date birthday = user.getBirthday(); 只需输入 user.getBirthday().var+Tab 即可。</p>
<p><strong>4 编辑：</strong></p>
<p>编辑中不得不说的一大神键就是能够自动按语法选中代码的 Ctrl+W 以及反向的 Ctrl+Shift+W 了。</p>
<p>此外，Ctrl+Left/Right 移动光标到前/后单词，Ctrl+[/] 移动到前/后代码块，这些类 Vim 风格的光标移动也是一大亮点。</p>
<p>以上 Ctrl+Left/Right/[] 加上 Shift 的话就能选中跳跃范围内的代码。 Alt+Forward/Backward 移动到前/后方法。</p>
<p>还有些非常普通的像 Ctrl+Y 删除行、Ctrl+D 复制行、Ctrl+ 折叠代码就不多说了。</p>
<p>关于光标移动再多扩展一点，除了 Intellij 本身已提供的功能外，我们还可以安装 ideaVim 或者 emacsIDEAs 享受到 Vim 的快速移动和 Emacs 的 AceJump 功能(超爽！)。</p>
<p>另外，Intellij 的书签功能也是不错的，用 Ctrl+Shift+Num 定义 1-10 书签(再次按这组快捷键则是删除书签)，然后通过 Ctrl+Num 跳转。</p>
<p>这避免了多次使用前/下一编辑位置 Ctrl+Left/Right 来回跳转的麻烦，而且此快捷键默认与 Windows 热键冲突(默认多了 Alt，与 Windows 改变显示器显示方向冲突，一不小心显示器就变成倒着显式的了，冏啊)。</p>
<p><strong>5 查找打开：</strong></p>
<p>类似 Eclipse，Intellij 的 Ctrl+N/Ctrl+Shift+N 可以打开类或资源，但 Intellij 更加智能一些，我们输入的任何字符都将看作模糊匹配，省却了 Eclipse 中还有输入 * 的麻烦。</p>
<p>最新版本的 IDEA 还加入了 Search Everywhere 功能，只需按 Shift+Shift 即可在一个弹出框中搜索任何东西，包括类、资源、配置项、方法等等。</p>
<p>类的继承关系则可用 Ctrl+H 打开类层次窗口，在继承层次上跳转则用 Ctrl+B/Ctrl+Alt+B 分别对应父类或父方法定义和子类或子方法实现，查看当前类的所有方法用 Ctrl+F12。</p>
<p>要找类或方法的使用也很简单，Alt+F7。</p>
<p>要查找文本的出现位置就用 Ctrl+F/Ctrl+Shift+F 在当前窗口或全工程中查找，再配合 F3/Shift+F3 前后移动到下一匹配处。</p>
<p>Intellij 更加智能的又一佐证是在任意菜单或显示窗口，都可以直接输入你要找的单词，Intellij 就会自动为你过滤。</p>
<p><strong>6 其他辅助：</strong></p>
<p>以上这些神键配上一些辅助快捷键，即可让你的双手 90% 以上的时间摆脱鼠标，专注于键盘仿佛在进行钢琴表演。这些不起眼却是至关重要的最后一块拼图有：</p>
<p>Ø  命令：Ctrl+Shift+A 可以查找所有 Intellij 的命令，并且每个命令后面还有其快捷键。所以它不仅是一大神键，也是查找学习快捷键的工具。</p>
<p>Ø  新建：Alt+Insert 可以新建类、方法等任何东西。</p>
<p>Ø  格式化代码：格式化 import 列表 Ctrl+Alt+O，格式化代码 Ctrl+Alt+L。</p>
<p>Ø  切换窗口：Alt+Num，常用的有 1-项目结构，3-搜索结果，4/5-运行调试。Ctrl+Tab 切换标签页，Ctrl+E/Ctrl+Shift+E 打开最近打开过的或编辑过的文件。</p>
<p>Ø  单元测试：Ctrl+Alt+T 创建单元测试用例。</p>
<p>Ø  运行：Alt+Shift+F10 运行程序，Shift+F9 启动调试，Ctrl+F2 停止。</p>
<p>Ø  调试：F7/F8/F9 分别对应 Step into，Step over，Continue。</p>
<p><strong>此外还有些我自定义的，例如水平分屏 Ctrl+| 等，和一些神奇的小功能 Ctrl+Shift+V 粘贴很早以前拷贝过的，Alt+Shift+Insert 进入到列模式进行按列选中。</strong></p>
<p>Ø  Top #10切来切去：Ctrl+Tab</p>
<p>Ø  Top #9选你所想：Ctrl+W</p>
<p>Ø  Top #8代码生成：Template/Postfix +Tab</p>
<p>Ø  Top #7发号施令：Ctrl+Shift+A</p>
<p>Ø  Top #6无处藏身：Shift+Shift</p>
<p>Ø  Top #5自动完成：Ctrl+Shift+Enter</p>
<p>Ø  Top #4创造万物：Alt+Insert</p>
<p><strong>太难割舍，前三名并列吧！</strong></p>
<p>Ø  Top #1智能补全：Ctrl+Shift+Space</p>
<p>Ø  Top #1自我修复：Alt+Enter</p>
<p>Ø  Top #1重构一切：Ctrl+Shift+Alt+T</p>
<p><strong>CTRL+ALT+ left/right 前后导航编辑过的地方 Ctrl＋Shift＋Backspace 可以跳转到上次编辑的地方</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MyBatis_6	注解开发]]></title>
        <id>https://ArtZoick.github.io//post/MyBatis_6</id>
        <link href="https://ArtZoick.github.io//post/MyBatis_6">
        </link>
        <updated>2019-07-03T14:53:40.000Z</updated>
        <content type="html"><![CDATA[<p>3、mybatis中的注解开发<br>
　　　　环境搭建<br>
　　　　单表CRUD操作（代理Dao方式）<br>
　　　　多表查询操作<br>
　　　　缓存的配置</p>
<h1 id="注解开发的crud不建议使用">注解开发的crud（不建议使用）</h1>
<h2 id="1iuserdao接口中使用注解">1.IUserDao接口中使用注解</h2>
<pre><code class="language-java">public interface IUserDao {

    /**
     * 查询所有用户
     * @return
     */
    @Select(&quot;select * from user&quot;)
    List&lt;User&gt; findAll();

    /**
     * 保存用户
     * @param user
     */
    @Insert(&quot;insert into user(username,address,sex,birthday)values(#{username},#{address},#{sex},#{birthday})&quot;)
    void saveUser(User user);

    /**
     * 更新用户
     * @param user
     */
    @Update(&quot;update user set username=#{username},sex=#{sex},birthday=#{birthday},address=#{address} where id=#{id}&quot;)
    void updateUser(User user);

    /**
     * 删除用户
     * @param userId
     */
    @Delete(&quot;delete from user where id=#{id} &quot;)
    void deleteUser(Integer userId);

    /**
     * 根据id查询用户
     * @param userId
     * @return
     */
    @Select(&quot;select * from user  where id=#{id} &quot;)
    User findById(Integer userId);

    /**
     * 根据用户名称模糊查询
     * @param username
     * @return
     */
//    @Select(&quot;select * from user where username like #{username} &quot;)
    @Select(&quot;select * from user where username like '%${value}%' &quot;)
    List&lt;User&gt; findUserByName(String username);

    /**
     * 查询总用户数量
     * @return
     */
    @Select(&quot;select count(*) from user &quot;)
    int findTotalUser();
}
</code></pre>
<h2 id="2测试类">2.测试类</h2>
<pre><code class="language-java">public class AnnotationCRUDTest {
    private InputStream in;
    private SqlSessionFactory factory;
    private SqlSession session;
    private IUserDao userDao;

    @Before
    public  void init()throws Exception{
        in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);
        factory = new SqlSessionFactoryBuilder().build(in);
        session = factory.openSession();
        userDao = session.getMapper(IUserDao.class);
    }

    @After
    public  void destroy()throws  Exception{
        session.commit();
        session.close();
        in.close();
    }


    @Test
    public void testSave(){
        User user = new User();
        user.setUsername(&quot;mybatis annotation&quot;);
        user.setAddress(&quot;北京市昌平区&quot;);

        userDao.saveUser(user);
    }

    @Test
    public void testUpdate(){
        User user = new User();
        user.setId(57);
        user.setUsername(&quot;mybatis annotation update&quot;);
        user.setAddress(&quot;北京市海淀区&quot;);
        user.setSex(&quot;男&quot;);
        user.setBirthday(new Date());

        userDao.updateUser(user);
    }


    @Test
    public void testDelete(){
        userDao.deleteUser(51);
    }

    @Test
    public void testFindOne(){
        User user = userDao.findById(57);
        System.out.println(user);
    }


    @Test
    public  void testFindByName(){
//        List&lt;User&gt; users = userDao.findUserByName(&quot;%mybatis%&quot;);
        List&lt;User&gt; users = userDao.findUserByName(&quot;mybatis&quot;);
        for(User user : users){
            System.out.println(user);
        }
    }

    @Test
    public  void testFindTotal(){
        int total = userDao.findTotalUser();
        System.out.println(total);
    }
}
</code></pre>
<h1 id="注解开发的多表查询">注解开发的多表查询</h1>
<p>可以这么记忆：<br>
你所需要对应的表是很多个注解用many<br>
对应一个的话就用one</p>
<p>demo功能阐述:<br>
查询用户账户的时候 返回用户的信息<br>
因为多个账户或者一个账户才对应一个用户</p>
<h2 id="多对一一对一">多对一（一对一）</h2>
<h3 id="1iaccountdao接口中使用注解">1.IAccountDao接口中使用注解</h3>
<pre><code class="language-java">public interface IAccountDao {

    /**
     * 查询所有账户，并且获取每个账户所属的用户信息
     * @return
     */
    @Select(&quot;select * from account&quot;)
    @Results(id=&quot;accountMap&quot;,value = {
            @Result(id=true,column = &quot;id&quot;,property = &quot;id&quot;),
            @Result(column = &quot;uid&quot;,property = &quot;uid&quot;),
            @Result(column = &quot;money&quot;,property = &quot;money&quot;),
            //这个注解是引入主表        FetchType(加载时机)  EAGER(立即加载)
            @Result(property = &quot;user&quot;,column = &quot;uid&quot;,one=@One(select=&quot;com.itheima.dao.IUserDao.findById&quot;,fetchType= FetchType.EAGER))
    })
    List&lt;Account&gt; findAll();

    /**
     * 根据用户id查询账户信息
     * @param userId
     * @return
     */
    @Select(&quot;select * from account where uid = #{userId}&quot;)
    List&lt;Account&gt; findAccountByUid(Integer userId);
}
</code></pre>
<h3 id="2account类中从表类">2.Account类中（从表类）</h3>
<pre><code class="language-java"> //多对一（mybatis中称之为一对一）的映射：一个账户只能属于一个用户
    private User user;

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }
</code></pre>
<h3 id="3测试类">3.测试类</h3>
<pre><code class="language-java">public class AccountTest {
    private InputStream in;
    private SqlSessionFactory factory;
    private SqlSession session;
    private IAccountDao accountDao;

    @Before
    public  void init()throws Exception{
        in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);
        factory = new SqlSessionFactoryBuilder().build(in);
        session = factory.openSession();
        accountDao = session.getMapper(IAccountDao.class);
    }

    @After
    public  void destroy()throws  Exception{
        session.commit();
        session.close();
        in.close();
    }

    @Test
    public  void  testFindAll(){
        List&lt;Account&gt; accounts = accountDao.findAll();
        for(Account account : accounts){
            System.out.println(&quot;----每个账户的信息-----&quot;);
            System.out.println(account);
            System.out.println(account.getUser());
        }
    }

}

</code></pre>
<h2 id="一对多多对多">一对多（多对多）</h2>
<p>demo功能阐述<br>
查询用户信息的时候 返回用户的账户信息<br>
因为一个用户对应多个用户的账户信息</p>
<p>使用的是延迟加载</p>
<h3 id="1iuserdao接口中使用注解-2">1.IUserDao接口中使用注解</h3>
<pre><code class="language-java">public interface IUserDao {

    /**
     * 查询所有用户
     * @return
     */
    @Select(&quot;select * from user&quot;)
    @Results(id=&quot;userMap&quot;,value={
            @Result(id=true,column = &quot;id&quot;,property = &quot;userId&quot;),
            @Result(column = &quot;username&quot;,property = &quot;userName&quot;),
            @Result(column = &quot;address&quot;,property = &quot;userAddress&quot;),
            @Result(column = &quot;sex&quot;,property = &quot;userSex&quot;),
            @Result(column = &quot;birthday&quot;,property = &quot;userBirthday&quot;),
            @Result(property = &quot;accounts&quot;,column = &quot;id&quot;,
                    many = @Many(select = &quot;com.itheima.dao.IAccountDao.findAccountByUid&quot;,
                                fetchType = FetchType.LAZY))
    })
    List&lt;User&gt; findAll();

    /**
     * 根据id查询用户
     * @param userId
     * @return
     */
    @Select(&quot;select * from user  where id=#{id} &quot;)
    @ResultMap(&quot;userMap&quot;)
    User findById(Integer userId);

    /**
     * 根据用户名称模糊查询
     * @param username
     * @return
     */
    @Select(&quot;select * from user where username like #{username} &quot;)
    @ResultMap(&quot;userMap&quot;)
    List&lt;User&gt; findUserByName(String username);

}
</code></pre>
<h3 id="2user类中从表类">2.User类中（从表类）</h3>
<pre><code class="language-java"> //一对多关系映射：一个用户对应多个账户
    private List&lt;Account&gt; accounts;

    public List&lt;Account&gt; getAccounts() {
        return accounts;
    }

    public void setAccounts(List&lt;Account&gt; accounts) {
        this.accounts = accounts;
    }
</code></pre>
<h1 id="注解开启二级缓存">注解开启二级缓存</h1>
<p>哪个Dao接口需要就写在哪儿</p>
<pre><code class="language-java">@CacheNamespace(blocking = true)
</code></pre>
<hr>
<h2 id="项目源码点鸡这里">项目源码：<a href="https://github.com/ArtZoick/MyBatis">点鸡这里</a></h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MyBatis_5	延迟加载 缓存 ]]></title>
        <id>https://ArtZoick.github.io//post/MyBatis_5</id>
        <link href="https://ArtZoick.github.io//post/MyBatis_5">
        </link>
        <updated>2019-07-03T14:52:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="mybatis_5延迟加载-缓存">MyBatis_5	延迟加载 缓存</h1>
<p>1、mybatis中的延迟加载<br>
　　　　问题：在一对多中，当我们有一个用户，它有100个账户。<br>
　　　　　　　在查询用户的时候，要不要把关联的账户查出来？<br>
　　　　　　　在查询账户的时候，要不要把关联的用户查出来？<br>
　　　　答案：在查询用户时，用户下的账户信息是，什么时候使用，什么时候查询的。<br>
　　　　　　　在查询账户时，账户的所属用户信息应该是随着账户查询时一起查询出来的。</p>
<p>什么是延迟加载<br>
　　　　　　　在真正使用数据时才发起查询，不用的时候不查询。按需加载（懒加载）<br>
　　　　什么是立即加载<br>
　　　　　　　不管用不用，只要一调用方法，马上发起查询<br>
　　　　在对应的四种表关系中：一对一，一对多，多对一，多对多。<br>
　　　　　　　一对多，多对多：通常情况下我们都是采用延迟加载。<br>
　　　　　　　多对一，一对一：通常情况下我们都是采用立即加载。</p>
<h2 id="一对一延迟加载">一对一延迟加载</h2>
<h3 id="1在sqlmapconfigxml中配置setting标签">1.在SqlMapConfig.xml中配置setting标签</h3>
<p>详情看中文官网（http://www.mybatis.org/mybatis-3/zh/configuration.html#settings）</p>
<pre><code class="language-xml">&lt;settings&gt;
        &lt;!-- 配置全局缓存--&gt;
        &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;

        &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;true&quot;/&gt;
    &lt;/settings&gt;
</code></pre>
<h3 id="2在iaccoutdaoxml中配置association标签">2.在IAccoutDao.xml中配置association标签</h3>
<pre><code class="language-xml">&lt;!--定义封装account和user的resultMap--&gt;
    &lt;resultMap id=&quot;accountUserMap&quot; type=&quot;Account&quot;&gt;
        &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt;

        &lt;result property=&quot;uid&quot; column=&quot;uid&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;money&quot; column=&quot;money&quot;&gt;&lt;/result&gt;

        &lt;!--一对一的关系映射，配置封装user的内容
        select属性的内容，查询用户的唯一标识符
        column属性的内容:用户根据id查询时，所需要参数的值--&gt;
        &lt;association property=&quot;user&quot; column=&quot;uid&quot; javaType=&quot;User&quot; select=&quot;com.daniel.dao.IUserDao.findById&quot;&gt;
            &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt;
            &lt;result property=&quot;username&quot; column=&quot;username&quot;&gt;&lt;/result&gt;
            &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt;
            &lt;result property=&quot;address&quot; column=&quot;address&quot;&gt;&lt;/result&gt;
            &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;&gt;&lt;/result&gt;
        &lt;/association&gt;
    &lt;/resultMap&gt;

    &lt;select id=&quot;findAll&quot; resultMap=&quot;accountUserMap&quot;&gt;
        select * from  account
    &lt;/select&gt;
</code></pre>
<h3 id="3测试类">3.测试类</h3>
<pre><code class="language-java"> @Test
    public void findAll(){
        List&lt;Account&gt; accounts = accoutDao.findAll();
        for (Account account:
             accounts) {
            System.out.println(&quot;每一个account的信息&quot;);
            System.out.println(account);
            System.out.println(account.getUser());
        }
    }
</code></pre>
<h2 id="一对多延迟加载">一对多延迟加载</h2>
<p>和一对一没有太多区别</p>
<h3 id="2在iuserdaoxml中配置collection标签">2.在IUserDao.xml中配置collection标签</h3>
<pre><code class="language-xml">&lt;!--定义封装account和user的resultMap--&gt;
    &lt;resultMap id=&quot;accountUserMap&quot; type=&quot;Account&quot;&gt;
         &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt;
        &lt;result property=&quot;username&quot; column=&quot;username&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;address&quot; column=&quot;address&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;&gt;&lt;/result&gt;

        &lt;!--一对一的关系映射，配置封装user的内容
        select属性的内容，查询用户的唯一标识符
        column属性的内容:用户根据id查询时，所需要参数的值--&gt;
    	&lt;collection property=&quot;accounts&quot; ofType=&quot;Account&quot; select=&quot;com.daniel.dao.IAccoutDao.findAccountByUid&quot; column=&quot;id&quot;&gt;
            &lt;id property=&quot;id&quot; column=&quot;aid&quot;&gt;&lt;/id&gt;
            &lt;result property=&quot;uid&quot; column=&quot;uid&quot;&gt;&lt;/result&gt;
            &lt;result property=&quot;money&quot; column=&quot;money&quot;&gt;&lt;/result&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;
</code></pre>
<h1 id="缓存">缓存</h1>
<p>2、mybatis中的缓存<br>
　　　　什么是缓存<br>
　　　　　　存在于内存中的临时数据<br>
　　　　为什么使用缓存<br>
　　　　　　减少与数据库的交互次数，提高执行效率。<br>
　　　　什么样的数据能使用缓存，什么样的数据不能使用<br>
　　　　　　适用于缓存：<br>
　　　　　　　　经常查询并且不经常改变的。<br>
　　　　　　　　数据的正确与否对最终结果影响不大的<br>
　　　　　　不适用于缓存：<br>
　　　　　　　　经常改变的数据。<br>
　　　　　　　　数据的正确与否对最终结果影响很大的。如，商品库存，银行汇率，股市牌价。<br>
mybatis中的一级缓存和二级缓存<br>
一级缓存：<br>
　　　　它指的是mybatis中SqlSession对象的缓存。<br>
　　　　当我们执行查询的时候，查询的结果会同时存入到SqlSession为我们提供的一块区域中。<br>
　　　　该区域的结构是一个Map。当我们再次查询同样的数据，mybatis会先去查询SqlSession中是否有，有的话直接拿来用。<br>
　　　　当SqlSession对象消失时，mybatis的一级缓存也就消失了。</p>
<p>二级缓存：<br>
　　　　它指的是mybatis中SqlSessionFactory对象的缓存。由同一个SqlSessionFactory对象创建的SqlSession共享其缓存。</p>
<p>二级缓存的使用步骤：<br>
　　　　　　　　第一步：让mybatis框架支持二级缓存（在SqlMapConfig.xml中配置）<br>
　　　　　　　　第二步：让当前的映射文件支持二级缓存（在IUserDao.xml中配置）<br>
　　　　　　　　第三步：让当前的操作支持二级缓存（在select标签中配置）　 x</p>
<h2 id="一级缓存">一级缓存</h2>
<p>其实mybatis中默认就是一级缓存了（平时的测试类就是一级缓存存在SqlSession中）</p>
<p><strong>一级缓存是SqlSession范围的缓存，当调用SqlSession的修改，添加，删除，commit()，close()等方法时，就会清空一级缓存。</strong></p>
<h2 id="二级缓存">二级缓存</h2>
<h3 id="1sqlmaoconfigxml中">1.SqlMaoConfig.xml中</h3>
<pre><code class="language-xml">&lt;settings&gt;
        &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;
&lt;/settings&gt;
</code></pre>
<h3 id="2在需要使用二级缓存的实体类的mapper中">2.在需要使用二级缓存的实体类的mapper中</h3>
<pre><code class="language-xml"> &lt;!--开启user支持二级缓存--&gt;
    &lt;cache/&gt;

 &lt;!-- 根据id查询用户   注意属性useCache --&gt;
    &lt;select id=&quot;findById&quot; parameterType=&quot;INT&quot; resultType=&quot;user&quot; useCache=&quot;true&quot;&gt;
        select * from user where id = #{uid}
    &lt;/select&gt;
</code></pre>
<h3 id="3测试类-2">3.测试类</h3>
<pre><code class="language-java">public class SecondLevelCacheTest {

    private InputStream in;
    private  SqlSessionFactory factory;

    @Before//用于在测试方法执行之前执行
    public void init()throws Exception{
        //1.读取配置文件，生成字节输入流
        in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);
        //2.获取SqlSessionFactory
        factory = new SqlSessionFactoryBuilder().build(in);

    }

    @After//用于在测试方法执行之后执行
    public void destroy()throws Exception{
        in.close();
    }

    /**
     * 测试二级缓存
     */
    @Test
    public void testFirstLevelCache(){
        SqlSession sqlSession1 = factory.openSession();
        IUserDao dao1 = sqlSession1.getMapper(IUserDao.class);
        User user1 = dao1.findById(41);
        System.out.println(user1);
        sqlSession1.close();//一级缓存消失

        SqlSession sqlSession2 = factory.openSession();
        IUserDao dao2 = sqlSession2.getMapper(IUserDao.class);
        User user2 = dao2.findById(41);
        System.out.println(user2);
        sqlSession2.close();

        System.out.println(user1 == user2);
    }

}
</code></pre>
<p>注意：<br>
从图中可以看出来第二次findbyId根本没有走数据库（数据都是从SqlSessionFactory的二级缓存中拿的 不是对象！）</p>
<h2 id="项目源码点鸡这里">项目源码：<a href="https://github.com/ArtZoick/MyBatis">点鸡这里</a></h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MyBatis_4	多表查询 ]]></title>
        <id>https://ArtZoick.github.io//post/MyBatis_4</id>
        <link href="https://ArtZoick.github.io//post/MyBatis_4">
        </link>
        <updated>2019-07-03T14:13:33.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一对一的关系映射">一对一的关系映射</h2>
<h3 id="示例">示例</h3>
<p>查询所有账户的时候同时获得当前账户的所有信息（多表查询常用方法）</p>
<h3 id="sql-语句">sql 语句</h3>
<p>sql 语句查询所有账户的时候同时获得当前账户的所有信息</p>
<pre><code class="language-sql">select u.*,a.id as aid,a.uid,a.money from account a ,user u where u.id=a.uid;
</code></pre>
<p>sql 语句查询所有账户的时候同时获得当前账户的所地址和姓名</p>
<pre><code class="language-sql">select a.*,u.username,u.address from account a ,user u where u.id=a.uid;
</code></pre>
<h3 id="1从表实体应该包含一个主表实体的对象引用">1.	从表实体应该包含一个主表实体的对象引用</h3>
<p>在Account类中</p>
<pre><code class="language-java">//从表实体应该包含一个主表实体的对象引用
    private User user;

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }

</code></pre>
<h3 id="2accountdao的接口中">2.AccountDao的接口中</h3>
<pre><code class="language-java"> //查询所有账户
    List&lt;Account&gt; findAll();
</code></pre>
<h3 id="3accountdao的mapper中">3.AccountDao的mapper中</h3>
<pre><code class="language-xml">&lt;mapper namespace=&quot;top.zoick.dao.IAccountDao&quot;&gt;
    &lt;!--定义封装account和user的resultMap--&gt;
    &lt;resultMap id=&quot;accountUserMap&quot; type=&quot;account&quot;&gt;
        &lt;id property=&quot;id&quot; column=&quot;aid&quot; /&gt;
        &lt;result property=&quot;uid&quot; column=&quot;uid&quot; /&gt;
        &lt;result property=&quot;money&quot; column=&quot;money&quot; /&gt;
        &lt;!--一对一的关系映射，配置封装user的内容 column中指名从表的外键 property=&quot;user&quot;指的是单个实体类的引用--&gt;
        &lt;association property=&quot;user&quot; column=&quot;uid&quot; javaType=&quot;User&quot;&gt;
            &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;
            &lt;result property=&quot;username&quot; column=&quot;username&quot;/&gt;
            &lt;result property=&quot;address&quot; column=&quot;address&quot;/&gt;
            &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt;
            &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;/&gt;
        &lt;/association&gt;
    &lt;/resultMap&gt;

    &lt;!--IAccountDao的查询所有--&gt;
    &lt;select id=&quot;findAll&quot; resultMap=&quot;accountUserMap&quot;&gt;
          select u.*,a.id as aid,a.uid,a.money from account a ,user u where u.id=a.uid;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p>注意事项中的javaType=“User” 一定要指名主体表的实体类名然后column中指名从表的外键！！</p>
<pre><code class="language-xml">&lt;association property=&quot;user&quot; column=&quot;uid&quot; javaType=&quot;User&quot;&gt;
</code></pre>
<h3 id="4accountdao的测试类中">4.AccountDao的测试类中</h3>
<pre><code class="language-java">@Test
public void findAll(){
    List&lt;Account&gt; accounts = accoutDao.findAll();
    for (Account account:accounts) {
       System.out.println(&quot;每一个account的信息&quot;);
       System.out.println(account);
       System.out.println(account.getUser());
     }
}
</code></pre>
<h3 id="第二种方法是创建一个accountuser类">第二种方法是创建一个AccountUser类</h3>
<p>不建议使用</p>
<hr>
<h2 id="一对多的关系映射">一对多的关系映射</h2>
<h3 id="示例用户和账户">示例：用户和账户</h3>
<p>一个用户可以有多个账户<br>
　　一个账户只能属于一个用户（多个账户也可以属于同一个用户）</p>
<h3 id="步骤">步骤：</h3>
<p>1、建立两张表：用户表 帐户表<br>
　　　　　　让用户表和账户表之前具备一对多的关系：需要使用外键在帐户表上添加<br>
　　2、建立两个实体类：用户实体类和账户实体类<br>
　　　　　　让用户和账户的实体类能体现出来一对多的关系<br>
　　3、配置两个配置文件<br>
　　　　　　用户的配置文件<br>
　　　　　　账户的配置文件<br>
　　4、实现配置：<br>
　　　　　　当我们查询用户的时候，可以同时得到用户下所包含的信息<br>
　　　　　　当我们查询账户时，我们可以同时得到账户所属的用户信息</p>
<h3 id="创建表与相关数据">创建表与相关数据</h3>
<pre><code class="language-sql">CREATE TABLE `account` (
  `ID` int(11) NOT NULL COMMENT '编号',
  `UID` int(11) default NULL COMMENT '用户编号',
  `MONEY` double default NULL COMMENT '金额',
  PRIMARY KEY  (`ID`),
  KEY `FK_Reference_8` (`UID`),
  CONSTRAINT `FK_Reference_8` FOREIGN KEY (`UID`) REFERENCES `user` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
</code></pre>
<h4 id="查询的sql语句">查询的sql语句</h4>
<pre><code class="language-sql">select * from user u left outer join account a on u.id = a.uid
</code></pre>
<p>left join（左连接）是left outer join的简写，返回左表中所有记录和右表中连接字段相等的记录，即返回的记录数和左表的记录数一样</p>
<p><img src="https://ArtZoick.github.io//post-images/mybatis/7.png" alt=""></p>
<h3 id="1主表实体中应该包含从表实体的集合引用">1.主表实体中应该包含从表实体的集合引用</h3>
<p>User类中</p>
<pre><code class="language-java">@Getter
@Setter
@ToString
public class User implements Serializable {
    private Integer id;
    private String username;
    private Date birthday;
    private String sex;
    private String address;

    //一对多关系映射，主表实体应该包含从表实体的集合应用
    private List&lt;Account&gt; accounts;

}
</code></pre>
<h3 id="2userdao的接口中">2.UserDao的接口中</h3>
<pre><code class="language-java">//  查询所有用户
 List&lt;User&gt; findAll();
</code></pre>
<h3 id="3userdao的mapper中">3.UserDao的mapper中</h3>
<pre><code class="language-xml">&lt;!--定义封装user和account的resultMap type主表实体类--&gt;
    &lt;resultMap id=&quot;userAccountMap&quot; type=&quot;User&quot;&gt;

        &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt;
        &lt;result property=&quot;username&quot; column=&quot;username&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;address&quot; column=&quot;address&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;&gt;&lt;/result&gt;

        &lt;!--一对多的关系映射，配置user封装accounts的内容--&gt;
        &lt;!--其中的property指的是从表的集合引用 ofType从表实体类--&gt;
        &lt;collection property=&quot;accounts&quot; ofType=&quot;Account&quot;&gt;
            &lt;id property=&quot;id&quot; column=&quot;aid&quot;&gt;&lt;/id&gt;
            &lt;result property=&quot;uid&quot; column=&quot;uid&quot;&gt;&lt;/result&gt;
            &lt;result property=&quot;money&quot; column=&quot;money&quot;&gt;&lt;/result&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;

    &lt;!--配置查询所有  其中id不能乱写必须是dao接口中的方法  --&gt;
    &lt;select id=&quot;findAll&quot; resultMap=&quot;userAccountMap&quot;&gt;
       select * from user u left outer join account a on u.id = a.uid
    &lt;/select&gt;
</code></pre>
<p>注意：一对一用的是association，一对多以及多对多用的是collection。</p>
<h3 id="4userdao的测试类中">4.UserDao的测试类中</h3>
<pre><code class="language-java">//查询所有（一个用户下的账号信息）
    @Test
    public  void findAll( ) throws Exception {
        List&lt;User&gt; users = userDao.findAll();
        for (User user:users
             ) {
            System.out.println(&quot;每个用户的信息&quot;);
            System.out.println(user);
            System.out.println(user.getAccounts());
        }
    }
</code></pre>
<h3 id="5成功运行实现上述功能">5.成功运行（实现上述功能）</h3>
<p><img src="https://ArtZoick.github.io//post-images/mybatis/8.png" alt=""></p>
<h2 id="多对多的关系映射">多对多的关系映射</h2>
<h3 id="示例用户与角色">示例：用户与角色</h3>
<p>一个用户可以有多个角色<br>
一个角色可以赋予多个用户</p>
<h3 id="步骤-2">步骤：</h3>
<p>1、建立两张表：用户表  用户表<br>
　　　　　　让用户和角色表具有多对多的关系。需要使用中间表，中间表中包含各自的主键，在中间表中是外键。<br>
　　2、建立两个实体类：用户实体类和角色实体类<br>
　　　　　　让用户和角色的实体类能体现出来多对多的关系<br>
　　　　　　各自包含对方一个集合引用<br>
　　3、配置两个配置文件<br>
　　　　　　用户的配置文件<br>
　　　　　　角色的配置文件<br>
　　4、实现配置：<br>
　　　　　　当我们查询用户的时候，可以同时得到用户下所包含角色的信息<br>
　　　　　　当我们查询角色时，我们可以同时得到角色所赋予的用户信息</p>
<h3 id="表设计">表设计</h3>
<h4 id="表设置如下">表设置如下：</h4>
<pre><code class="language-sql">CREATE TABLE `role` (
  `ID` int(11) NOT NULL COMMENT '编号',
  `ROLE_NAME` varchar(30) default NULL COMMENT '角色名称',
  `ROLE_DESC` varchar(60) default NULL COMMENT '角色描述',
  PRIMARY KEY  (`ID`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

CREATE TABLE `user_role` (
  `UID` int(11) NOT NULL COMMENT '用户编号',
  `RID` int(11) NOT NULL COMMENT '角色编号',
  PRIMARY KEY  (`UID`,`RID`),
  KEY `FK_Reference_10` (`RID`),
  CONSTRAINT `FK_Reference_10` FOREIGN KEY (`RID`) REFERENCES `role` (`ID`),
  CONSTRAINT `FK_Reference_9` FOREIGN KEY (`UID`) REFERENCES `user` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
</code></pre>
<pre><code class="language-sql">insert  into `role`(`ID`,`ROLE_NAME`,`ROLE_DESC`) values (1,'院长','管理整个学院'),(2,'总裁','管理整个公司'),(3,'校长','管理整个学校');
insert  into `user_role`(`UID`,`RID`) values (41,1),(45,1),(41,2);
</code></pre>
<h4 id="表数据如下">表数据如下：</h4>
<p><img src="https://ArtZoick.github.io//post-images/mybatis/9.png" alt=""></p>
<p><img src="https://ArtZoick.github.io//post-images/mybatis/9_1.png" alt=""></p>
<p><img src="https://ArtZoick.github.io//post-images/mybatis/9_2.png" alt=""></p>
<h4 id="sql语句多表外链接查询语句">sql语句(多表外链接查询语句)</h4>
<pre><code class="language-sql">select u.*, r.id as rid,r.role_name,r.role_desc from role r   
left outer join user_role ur on r.id = ur.rid   
left outer join user u on u.id=ur.uid  
</code></pre>
<p>注意其中每行末尾的空格<br>
**目的：**为了查询角色下的用户信息<br>
**步骤：**以role表（别名）为主表，左外连接user_role表（别名ur,此表为中间表），连接条件r.id = ur.rid 。<br>
再以这两个表组合的表左外连接user表，连接条件u.id=ur.uid 。</p>
<p><strong>注意：</strong><a href="https://jingyan.baidu.com/article/60ccbceb9578f164cab197f4.html">数据库连接（内链接，外连接（左连接，右连接）</a></p>
<h4 id="查询结果">查询结果</h4>
<p><img src="https://ArtZoick.github.io//post-images/mybatis/10.png" alt=""></p>
<h3 id="1一个实体表中包含另一个实体表的集合引用">1.一个实体表中包含另一个实体表的集合引用</h3>
<p>由于是多对多的关系所有不分从表和主表</p>
<pre><code class="language-java">@Setter
@Getter
@ToString
public class Role implements Serializable {

    private Integer roleId;
    private String roleName;
    private String roleDesc;

    /**
     * 多对多的关系映射：一个角色可以赋予多个用户
     */
    private List&lt;User&gt; users;
}

</code></pre>
<h3 id="2roledao的接口中定义该方法">2.RoleDao的接口中定义该方法</h3>
<pre><code class="language-java">List&lt;Role&gt; findAll();
</code></pre>
<h3 id="3roledao的mapper中">3.RoleDao的mapper中</h3>
<pre><code class="language-xml"> &lt;resultMap id=&quot;roleMap&quot; type=&quot;role&quot;&gt;
        &lt;id property=&quot;roleId&quot; column=&quot;rid&quot;&gt;&lt;/id&gt;
        &lt;result property=&quot;roleName&quot; column=&quot;role_name&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;roleDesc&quot; column=&quot;role_desc&quot;&gt;&lt;/result&gt;
        &lt;collection property=&quot;users&quot; ofType=&quot;user&quot;&gt;
            &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt;
            &lt;result property=&quot;username&quot; column=&quot;username&quot;&gt;&lt;/result&gt;
            &lt;result property=&quot;address&quot; column=&quot;address&quot;&gt;&lt;/result&gt;
            &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt;
            &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;&gt;&lt;/result&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;


    &lt;select id=&quot;findAll&quot; resultMap=&quot;roleMap&quot;&gt;
       select u.*,r.id as rid,r.role_name,r.role_desc from role r
        left outer join user_role ur on r.id = ur.rid
        left outer join user u on u.id=ur.uid
    &lt;/select&gt;
</code></pre>
<h3 id="4roledao的测试类中">4.RoleDao的测试类中</h3>
<pre><code class="language-java">@Test
    public void findAll(){
        List&lt;Role&gt; roles  = roleDao.findAll();
        for (Role role:roles
             ) {
            System.out.println(&quot;=====每个角色的信息=====&quot;);
            System.out.println(role);
            System.out.println(role.getUsers());
        }
    }
</code></pre>
<h3 id="5成功运行实现上述功能-2">5.成功运行（实现上述功能）</h3>
<h3 id=""><img src="https://ArtZoick.github.io//post-images/mybatis/10_1.png" alt=""></h3>
<h3 id="同理可得用户的全部信息与用户的角色">=<mark>同理可得用户的全部信息与用户的角色</mark>=</h3>
<h4 id="sql语句">sql语句</h4>
<pre><code class="language-sql">select u.*, r.id as rid,r.role_name,r.role_desc from user u
left outer join user_role ur on u.id = ur.uid
left outer join role r on r.id=ur.rid
</code></pre>
<h3 id="6实体类user包含对accounts的引用">6.实体类User包含对Accounts的引用</h3>
<pre><code class="language-java">@Getter
@Setter
@ToString
public class User implements Serializable {
    private Integer id;
    private String username;
    private Date birthday;
    private String sex;
    private String address;
    
    //实体类User包含对Accounts的引用
    private List&lt;Role&gt; roles;
}

</code></pre>
<h3 id="7userdao的接口中定义该方法">7.UserDao的接口中定义该方法</h3>
<pre><code class="language-java">  //  查询所有
    List&lt;User&gt; findAll();
</code></pre>
<h3 id="8userdao的mapper中">8.UserDao的mapper中</h3>
<pre><code class="language-xml"> &lt;resultMap id=&quot;userMap&quot; type=&quot;user&quot;&gt;

        &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt;
        &lt;result property=&quot;username&quot; column=&quot;username&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;address&quot; column=&quot;address&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;&gt;&lt;/result&gt;


        &lt;collection property=&quot;roles&quot; ofType=&quot;role&quot;&gt;
            &lt;id property=&quot;roleId&quot; column=&quot;rid&quot;&gt;&lt;/id&gt;
            &lt;result property=&quot;roleName&quot; column=&quot;role_name&quot;&gt;&lt;/result&gt;
            &lt;result property=&quot;roleDesc&quot; column=&quot;role_desc&quot;&gt;&lt;/result&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;


    &lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot;&gt;
       select u.*,r.id as rid,r.role_name,r.role_desc from user u

      left outer join user_role ur on u.id = ur.uid

       left outer join role r on r.id=ur.rid
    &lt;/select&gt;

</code></pre>
<h3 id="9userdao的测试类中">9.UserDao的测试类中</h3>
<pre><code> @Test
    public  void findAll( ) throws Exception {

        List&lt;User&gt; users = userDao.findAll();
        for (User user:users
             ) {
            System.out.println(&quot;====每个用户的信息====&quot;);
            System.out.println(user);
            System.out.println(user.getRoles());
        }

    }
</code></pre>
<h3 id="10成功运行实现上述功能">10.成功运行（实现上述功能）</h3>
<hr>
<h1 id="jndi">JNDI</h1>
<p>JNDI是 Java 命名与目录接口（Java Naming and Directory Interface），在J2EE规范中是重要的规范之一。</p>
<p><img src="https://ArtZoick.github.io//post-images/mybatis/11.png" alt=""></p>
<hr>
<h2 id="项目源码点鸡这里">项目源码：<a href="https://github.com/ArtZoick/MyBatis">点鸡这里</a></h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ MyBatis_3	连接池、事务控制、动态SQL]]></title>
        <id>https://ArtZoick.github.io//post/MyBatis_3</id>
        <link href="https://ArtZoick.github.io//post/MyBatis_3">
        </link>
        <updated>2019-07-03T14:11:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="连接池">连接池</h2>
<p><strong>１、连接池：</strong><br>
　　　　在实际开发中都会使用连接池<br>
　　　　因为它可以减少我们获取连接所消耗的时间</p>
<p><strong>２、mybatis中的连接池：</strong><br>
　　　　mybatis连接池提供了3种配置方式：<br>
　　　　配置的位置：<br>
　　　　　　主配置文件SqlMapConfig.xml中的dataSource标签，type属性就是表示采用何种连接池方式。<br>
　　　　type属性的值：<br>
　　　　　　<em><strong>POOLED</strong></em>　　采用传统的javax.sql.DataSource规范中的连接池，mybatis中有针对规范的实现<br>
　　　　　　<em><strong>UNPOOLED</strong></em>　采用传统的获取连接的方式，虽然也实现javax.sql.DataSource接口，但是并没有使用池的思想<br>
　　　　　　<em><strong>JNDI</strong></em>　　　采用服务器提供的JNDI技术实现，来获取DataSource对象，不同的服务器所能拿到DataSource是不一样的<br>
　　　　注意：如果不是web或者maven的war工程，是不能使用的<br>
　　　　　　学习时使用的时tomcat服务器，采用的连接池就是dbcp连接池</p>
<h2 id="mybatis中的事务">MyBatis中的事务</h2>
<p>什么是事务<br>
　　事务的四大特性ACID<br>
　　不考虑隔离性会产生的3个问题<br>
　　解决办法：四种隔离级别</p>
<p>它是通过sqlsession对象的commit方法和rollback方法实现事务的提交和回滚</p>
<h2 id="动态sql">动态SQL</h2>
<h3 id="if标签的使用">if标签的使用</h3>
<h4 id="1接口中定义">1.接口中定义</h4>
<pre><code class="language-java"> List&lt;User&gt; findByCondition(User user);
</code></pre>
<h4 id="2mapper中定义">2.mapper中定义</h4>
<pre><code class="language-xml">&lt;select id=&quot;findByCondition&quot; resultMap=&quot;userMap&quot; parameterType=&quot;user&quot;&gt;
        select * from user where 1=1
        &lt;if test=&quot;userName != null&quot;&gt;
            and username = #{userName}
        &lt;/if&gt;
        &lt;if test=&quot;userSex != null&quot;&gt;
            and sex = #{userSex}
        &lt;/if&gt;    
&lt;/select&gt;
</code></pre>
<p>其中： <if test="userName != null">这条语句中，userName值得是实体类中的属性名， and username = #{userName}这里是将实体类的userName传给数据库的username</p>
<h3 id="3测试类中测试">3.测试类中测试</h3>
<pre><code class="language-java">/**
     * 测试findByCondition
     * @throws IOException
     */
    @Test
    public void testFindByCondiion() throws Exception {
        User u = new User();
        u.setUserName(&quot;zoick&quot;);
//        u.setUserSex(&quot;女&quot;);
        init();
        //5.使用代理对象执行方法
        List&lt;User&gt; users = userDao.findByCondition(u);
        for (User user : users) {
            System.out.println(user);
        }
    }

</code></pre>
<h2 id="where和foreach标签的使用">where和foreach标签的使用</h2>
<p>用于多个查询的sql<br>
select * from user where id in(41,42,45)<br>
通过一个类中传入集合的方法<br>
QueryVo类</p>
<pre><code class="language-java">@Getter
@Setter
public class QueryVo {

    private User user;
    private List&lt;Integer&gt; ids;
}

</code></pre>
<h3 id="1接口中定义-2">1.接口中定义</h3>
<pre><code class="language-java">    /**
     * 根据Queryvo中提供的id集合，查询用户信息
     * @param vo
     * @return
     */
    List&lt;User&gt; findUserInIds(QueryVo vo);
</code></pre>
<h3 id="2mapper中定义-2">2.mapper中定义</h3>
<pre><code class="language-xml">&lt;!--根据queryvo中Id集合实现查询用户列表--&gt;
    &lt;select id=&quot;findUserInIds&quot; resultMap=&quot;userMap&quot; parameterType=&quot;queryvo&quot;&gt;
        select * from user
        &lt;where&gt;
            &lt;if test=&quot;ids != null and ids.size()&gt;0&quot;&gt;
                &lt;foreach collection=&quot;ids&quot; open=&quot;and id in (&quot; close=&quot;)&quot; item=&quot;uuuuid&quot; separator=&quot;,&quot;&gt;
                    #{uuuuid}
                &lt;/foreach&gt;
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
</code></pre>
<p>注意if标签中的内容都是来源于parameterType参数</p>
<h3 id="3测试代码">3.测试代码</h3>
<pre><code class="language-java">/**
     * 测试foreach标签的使用
     *
     * @throws IOException
     */
    @Test
    public void testFindInIds () throws Exception {
        QueryVo vo = new QueryVo();
        List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
        list.add(41);
        list.add(42);
        list.add(45);
        vo.setIds(list);
        init();
        //5.使用代理对象执行方法
        List&lt;User&gt; users = userDao.findUserInIds(vo);
        for (User user : users) {
            System.out.println(user);
        }
    }
</code></pre>
<h3 id="抽取重复的sql">抽取重复的sql</h3>
<h4 id="1定义">1.定义</h4>
<pre><code class="language-xml">&lt;!--抽取重复的sql语句--&gt;
    &lt;sql id=&quot;defaultUser&quot;&gt;
        select * from user
    &lt;/sql&gt;
</code></pre>
<h4 id="2使用">2.使用</h4>
<pre><code class="language-xml">&lt;include refid=&quot;defaultUser&quot;&gt;&lt;/include&gt;
</code></pre>
<pre><code class="language-xml"> &lt;!--抽取重复的sql语句--&gt;
    &lt;sql id=&quot;defaultUser&quot;&gt;
        select * from user
    &lt;/sql&gt;

    &lt;!--配置查询所有  其中id不能乱写必须是dao接口中的方法  resultType写的是实体类的全路径--&gt;
    &lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot;&gt;
        &lt;include refid=&quot;defaultUser&quot;/&gt;
    &lt;/select&gt;
</code></pre>
<p><strong>注意：</strong> 尽量不要使用分号，sql语句可能会拼接</p>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MyBatis_2	基本的CRUD]]></title>
        <id>https://ArtZoick.github.io//post/MyBatis_2</id>
        <link href="https://ArtZoick.github.io//post/MyBatis_2">
        </link>
        <updated>2019-07-03T14:09:56.000Z</updated>
        <content type="html"><![CDATA[<p>1、回顾MyBatis的自定义再分析和环境搭建+完善基于注解的MyBatis<br>
2、MyBatis的CRUD（基于代理dao的方式）<br>
3、MyBatis中的参数深入及结果集的深入<br>
4、MyBatis中基于传统dao的方式（编写dao的实现类）---了解的内容<br>
5、MyBatis中的配置(主配置文件：SqlMapConfig.xml)<br>
　　　　　properties标签<br>
　　　　　typeAliases标签<br>
　　　　　mappers标签</p>
<p><strong>OGNL表达式:</strong><br>
Object Graphic Navigation Language<br>
对象 　　图　　　导航 　　　语言<br>
它是通过对象的取值方法来获取数据。·在写法上把get给省略了<br>
比如:我们获取用户的名称<br>
　　　　类中的写法:user.getUsername,<br>
　　　　OGNL表达式写法:user.username<br>
mybatis中为什么能直接写username,而不用user.呢:<br>
　　　　因为在parameterType中已经提供了属性所属的类, 所以此时不需要写对象名</p>
<h2 id="完整接口类代码">完整接口类代码</h2>
<pre><code class="language-java">package top.zoick.dao;

import top.zoick.domain.QueryVo;
import top.zoick.domain.User;

import java.util.List;

/**
 * @author zoick
 * @date 2019/7/4 17:34
 * 用户的持久层接口
 */
public interface IUserDao {

    /**
     * 查询所有操作
     * @return
     */
    List&lt;User&gt; findAll();

    /**
     * 保存用户
     * @param user
     */
    void saveUser(User user);

    /**
     * 更新用户
     * @param user
     */
    void updateUser(User user);

    /**
     * 根据删除用户
     * @param userId
     */
    void deleteUser(Integer userId);

    /**
     * 根据id查询用户信息
     * @param userId
     * @return
     */
    User findByID(Integer userId);

    /**
     * 根据名称模糊查询用户信息
     * @param username
     * @return
     */
    List&lt;User&gt; findByName(String username);


    /**
     * 查询总用户数
     * @return
     */
    Integer findTotal();

    /**
     * 根据QueryVo中的条件查询用户
     * @param vo
     * @return
     */
    List&lt;User&gt; findUserByVo(QueryVo vo);


}
</code></pre>
<h2 id="完整mapper代码">完整mapper代码</h2>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;mapper namespace=&quot;top.zoick.dao.IUserDao&quot;&gt;

    &lt;!--配置查询结果的列名和实体类的属性名的对应关系--&gt;
    &lt;resultMap id=&quot;userMap&quot; type=&quot;top.zoick.domain.User&quot;&gt;
        &lt;!--主键字段的对应--&gt;
        &lt;id property=&quot;userId&quot; column=&quot;id&quot;&gt;&lt;/id&gt;
        &lt;!--非主键字段的对应--&gt;
        &lt;result property=&quot;userName&quot; column=&quot;username&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;userAddress&quot; column=&quot;address&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;userSex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;userBirthday&quot; column=&quot;birthday&quot;&gt;&lt;/result&gt;
    &lt;/resultMap&gt;
    

    &lt;!--配置查询所有  其中id不能乱写必须是dao接口中的方法  resultType写的是实体类的全路径--&gt;
    &lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot;&gt;
        &lt;!--实体类中的属性名和数据库表中元素名字匹配不上时，使用别名即可匹配。id为数据库中表的列名，userId为实体类中属性名--&gt;
        &lt;!--select id as userId,username as userName,address as userAddress ,sex as userSex, birthday as userBirthday from user--&gt;
        select * from user
&lt;/select&gt;

    &lt;!--保存用户--&gt;
    &lt;insert id=&quot;saveUser&quot; parameterType=&quot;top.zoick.domain.User&quot;&gt;
        &lt;!--配置插入操作后，获取插入数据的id--&gt;
            &lt;!--keyProperty对应实体类属性名:id，keyColumn对应于数据库:id resultType为数据类型，order为在这条insert sql语句执行前还是执行后做--&gt;
        &lt;selectKey keyProperty=&quot;userId&quot; keyColumn=&quot;id&quot; resultType=&quot;int&quot; order=&quot;AFTER&quot;&gt;
            select last_insert_id();
        &lt;/selectKey&gt;
        insert into user (username,address,sex,birthday) values (#{userName},#{userAddress},#{userSex},#{userBirthday})
    &lt;/insert&gt;

    &lt;!--更新用户--&gt;
    &lt;update id=&quot;updateUser&quot; parameterType=&quot;usER&quot;&gt;
        update user set username=#{userName},address=#{userAddress},sex=#{userSex},birthday=#{userBirthday} where id=#{userId}
    &lt;/update&gt;

    &lt;!--删除用户--&gt;
    &lt;!--当参数值为基本类型或者基本类型包装类时，SQL语句中的占位符可以随意写--&gt;
    &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;Integer&quot;&gt;
        delete from user where id = #{anyzhanweifu}
    &lt;/delete&gt;

    &lt;!--根据id查询用户--&gt;
    &lt;select id=&quot;findByID&quot; parameterType=&quot;INT&quot; resultMap=&quot;userMap&quot;&gt;
        select * from user where id = #{uuuuuuid}
    &lt;/select&gt;

    &lt;!--根据名称模糊查询--&gt;
    &lt;select id=&quot;findByName&quot; parameterType=&quot;String&quot; resultMap=&quot;userMap&quot;&gt;
        select * from user where username like #{namenamenamename}
        &lt;!--select * from user where username like '%${value}%'--&gt;
    &lt;/select&gt;

    &lt;!--查询记录的总用户条数--&gt;
    &lt;select id=&quot;findTotal&quot; resultType=&quot;Integer&quot;&gt;
        select count(id) from user
    &lt;/select&gt;

    &lt;!--根据QueryVo的条件查询用户--&gt;
    &lt;select id=&quot;findUserByVo&quot; parameterType=&quot;top.zoick.domain.QueryVo&quot; resultMap=&quot;userMap&quot;&gt;
        select * from user where username like #{user.username}
    &lt;/select&gt;

&lt;/mapper&gt;
</code></pre>
<h2 id="完整测试类代码">完整测试类代码</h2>
<pre><code class="language-java">package top.zoick.test;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import top.zoick.dao.IUserDao;
import top.zoick.domain.QueryVo;
import top.zoick.domain.User;

import java.io.IOException;
import java.io.InputStream;
import java.util.Date;
import java.util.List;

/**
 * @author zoick
 * @date 2019/7/4 21:27
 * mybatis的入门案例
 */
public class MybatisTest {

    private InputStream in;
    private SqlSession sqlSession;
    private IUserDao userDao;

    @Before//用于在测试方法执行之前执行
    public void init() throws Exception {
        //1.读取配置文件
        in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);
        //2.创建SqlSessionFactory工厂
        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in);
        //3.使用工厂生产SqlSession对象
        sqlSession = factory.openSession();
        //4.使用SqlSession创建Dao接口的代理对象
        userDao = sqlSession.getMapper(IUserDao.class);
    }

    @After//用于在测试方法执行之后执行
    public void destory() throws IOException {

        //提交事务
        sqlSession.commit();

        //6.释放资源
        sqlSession.close();
        in.close();

    }

    /**
     * 测试查询所有
     *
     * @throws IOException
     */
    @Test
    public void testFindALl() throws Exception {
        init();
        //5.使用代理对象执行方法
        List&lt;User&gt; users = userDao.findAll();
        for (User user : users) {
            System.out.println(user);
        }
    }

    /**
     * 测试保存操作
     */
    @Test
    public void testSave() throws Exception {
        User user = new User();
        user.setUserName(&quot;modify user&quot;);
        user.setUserAddress(&quot;天津&quot;);
        user.setUserBirthday(new Date());
        user.setUserSex(&quot;男&quot;);

        System.out.println(&quot;保存操作之前：&quot; + user);
        init();
        //5.使用代理对象执行方法
        userDao.saveUser(user);

        System.out.println(&quot;保存操作之后：&quot; + user);
    }

    /**
     * 测试更新操作
     */
    @Test
    public void testUpdate() throws Exception {
        User user = new User();
        user.setUserId(51);
        user.setUserName(&quot;mybatis updateUser&quot;);
        user.setUserAddress(&quot;天津1&quot;);
        user.setUserBirthday(new Date());
        user.setUserSex(&quot;男&quot;);

        init();
        //5.使用代理对象执行方法
        userDao.updateUser(user);
    }

    /**
     * 测试删除
     */
    @Test
    public void testDelete() throws Exception {

        init();
        //5.执行删除方法
        userDao.deleteUser(51);
    }

    /**
     * 测试根据id查询用户
     */
    @Test
    public void testFindById() throws Exception {
        init();
        //5.执行查询一个
        User user = userDao.findByID(42);
        System.out.println(user);
    }

    /**
     * 测试名称模糊查询用户信息
     */
    @Test
    public void testFindByName() throws Exception {
        init();
        //5.执行模糊查询
        List&lt;User&gt; user = userDao.findByName(&quot;%彭%&quot;);
//        List&lt;User&gt; user = userDao.findByName(&quot;彭&quot;);
        System.out.println(user);
    }

    /**
     * 测试查询用户条数
     */
    @Test
    public void testFindTotal() throws Exception {
        init();
        //执行查询总记录条数
        Integer number = userDao.findTotal();
        System.out.println(&quot;总记录条数为：&quot; + number);
    }

    /**
     * 测试使用QueryVo作为查询条件
     */
    @Test
    public void testFindUserByVo() throws Exception {
        QueryVo vo = new QueryVo();
        User user = new User();
        user.setUserName(&quot;%彭%&quot;);
        vo.setUser(user);

        List&lt;User&gt; users = userDao.findUserByVo(vo);
        for (User u : users) {
            System.out.println(u);
        }
    }
}
</code></pre>
<h2 id="一些注意点">一些注意点：</h2>
<h3 id="1-数据库表的元素名与实体类的属性名不对应的解决">1、数据库表的元素名与实体类的属性名不对应的解决：</h3>
<p>1.起别名：</p>
<pre><code class="language-xml"> &lt;!--配置查询所有  其中id不能乱写必须是dao接口中的方法  resultType写的是实体类的全路径--&gt;
    &lt;select id=&quot;findAll&quot; resultType=&quot;top.zoick.domain.User&quot;&gt;
        &lt;!--实体类中的属性名和数据库表中元素名字匹配不上时，使用别名即可匹配。id为数据库中表的列名，userId为实体类中属性名--&gt;
        select id as userId,username as userName,address as userAddress ,sex as userSex, birthday as userBirthday from user
    &lt;/select&gt;
</code></pre>
<p>2.配置查询结果的列名和实体类的属性名的对应关系：</p>
<pre><code class="language-xml"> &lt;!--配置查询结果的列名和实体类的属性名的对应关系--&gt;
    &lt;resultMap id=&quot;userMap&quot; type=&quot;top.zoick.domain.User&quot;&gt;
        &lt;!--主键字段的对应--&gt;
        &lt;id property=&quot;userId&quot; column=&quot;id&quot;&gt;&lt;/id&gt;
        &lt;!--非主键字段的对应--&gt;
        &lt;result property=&quot;userName&quot; column=&quot;username&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;userAddress&quot; column=&quot;address&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;userSex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt;
        &lt;result property=&quot;userBirthday&quot; column=&quot;bithday&quot;&gt;&lt;/result&gt;
    &lt;/resultMap&gt;

再在查询的sql语句的xml中加入配置
  &lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot;&gt;
        select * from user
  &lt;/select&gt;
</code></pre>
<h3 id="2-配置xml中的属性标签">2、配置xml中的属性标签</h3>
<h3 id="1使用properties配置数据库连接欸信息">(1)使用properties配置数据库连接欸信息</h3>
<p>可以在标签内部配置数据库连接信息，也可以通过外部文件来配置数据库连接信息。</p>
<p><strong>第一种url属性(不常用)</strong></p>
<p>URL属性：<br>
　　URL:Uniform Resource Locator　统一资源定位符 可以唯一标志一个资源的位置<br>
　　写法必须是<br>
　　　　http://localhost:8080/mybatisserver/demo1Servlet<br>
　　　　协议　　主机　　端口　URI<br>
　　URI:Uniform Resource Identifier   统一资源标识符 是在应用中可以可以唯一标志一个资源的位置<br>
　　URL&gt;URI（精准性）</p>
<pre><code class="language-xml">&lt;properties url=&quot;file:///C:/Users/zoick/OneDrive/Tomorrow/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/MyBatis/day02/day02_eesy_02mybatisCRUD/src/main/resources/jdbcConfig.properties&quot;&gt;

&lt;/properties&gt;
</code></pre>
<p><strong>第二种resource属性（常用）</strong><br>
用于指定配置文件的位置，是按照类路径来写的，必须存在于类路径下</p>
<pre><code class="language-xml">&lt;properties resource=&quot;jdbcConfig.properties&quot;&gt;

&lt;/properties&gt;
</code></pre>
<h3 id="2使用typealiases配置别名">(2)使用typeAliases配置别名</h3>
<pre><code class="language-xml">&lt;!--使用typeAliases配置别名，他只能配置domain中类的别名--&gt;
    &lt;typeAliases&gt;
        &lt;!--typeAlias用于配置别名，type属性指定的是实体类中的全限定类名。alias属性指定别名，当指定了别名后不在区分大小写--&gt;
        &lt;typeAlias type=&quot;top.zoick.domain.User&quot; alias=&quot;user&quot;&gt;&lt;/typeAlias&gt;
    &lt;/typeAliases&gt;
</code></pre>
<h3 id="3使用package配置别名">(3)使用package配置别名</h3>
<pre><code class="language-xml"> &lt;typeAliases&gt;
        &lt;!--用于指定要配置别名的包，当指定后，该包下的实体类都会注册别名，并且类名就是别名，不再区分大小写--&gt;
        &lt;package name=&quot;top.zoick.domain&quot;/&gt;
    &lt;/typeAliases&gt;
</code></pre>
<p>其中，配置映射文件位置的<mappers>中也有package这个标签</p>
<pre><code class="language-xml">   &lt;mappers&gt;
&lt;!--        &lt;mapper resource=&quot;top/zoick/dao/IUserDao.xml&quot;/&gt;--&gt;
        &lt;!--package标签是用于指定dao接口所在的包，当指定了之后就不需要再写mapepr以及resource或者class了--&gt;
        &lt;package name=&quot;top.zoick.dao&quot;/&gt;
    &lt;/mappers&gt;

</code></pre>
<p>配置文件：</p>
<p><em>SqlMapConfig.xml</em></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;!-- mybatis主配置文件--&gt;
&lt;configuration&gt;
    &lt;!--配置properties
        可以在标签内部配置数据库连接信息 也可以通过外部文件来配置数据库连接信息
        resource 属性：（常用）
                用于指定配置文件的位置，是按照类路径来写的，必须存在于类路径下
        URL属性：
            URL:Uniform Resource Locator    统一资源定位符 可以唯一标志一个资源的位置
            写法必须是
                http://localhost:8080/mybatisserver/demo1Servlet
                协议      主机    端口     URI
            URI:Uniform Resource Identifier 统一资源标识符 是在应用中可以可以唯一标志一个资源的位置
            URL&gt;URI（精准性）
    --&gt;
    &lt;properties url=&quot;file:///C:/Users/zoick/OneDrive/Tomorrow/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/MyBatis/day02/day02_eesy_02mybatisCRUD/src/main/resources/jdbcConfig.properties&quot;&gt;
&lt;!--        &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;--&gt;
&lt;!--        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/eesy_mybatis&quot;/&gt;--&gt;
&lt;!--        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;--&gt;
&lt;!--        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;--&gt;
    &lt;/properties&gt;
    
    &lt;!--使用typeAliases配置别名，他只能配置domain中类的别名--&gt;
    &lt;typeAliases&gt;
        &lt;!--typeAlias用于配置别名，type属性指定的是实体类中的全限定类名。alias属性指定别名，当指定了别名后不在区分大小写--&gt;
&lt;!--    &lt;typeAlias type=&quot;top.zoick.domain.User&quot; alias=&quot;user&quot;&gt;&lt;/typeAlias&gt;--&gt;

        &lt;!--用于指定要配置别名的包，当指定后，该包下的实体类都会注册别名，并且类名就是别名，不再区分大小写--&gt;
        &lt;package name=&quot;top.zoick.domain&quot;/&gt;
    &lt;/typeAliases&gt;
    
    

    &lt;!-- 配置环境--&gt;
    &lt;environments default=&quot;mysql&quot;&gt;
        &lt;!-- 配置mysql的环境--&gt;
        &lt;environment id=&quot;mysql&quot;&gt;
            &lt;!-- 配置事务的类型--&gt;
            &lt;transactionManager type=&quot;jdbc&quot;&gt;&lt;/transactionManager&gt;
            &lt;!-- 配置数据源（连接池）--&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;!-- 配置链接数据库的四个基本信息--&gt;
                &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;

    &lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件--&gt;
    &lt;mappers&gt;
&lt;!--        &lt;mapper resource=&quot;top/zoick/dao/IUserDao.xml&quot;/&gt;--&gt;
        &lt;!--package标签是用于指定dao接口所在的包，当指定了之后就不需要再写mapepr以及resource或者class了--&gt;
        &lt;package name=&quot;top.zoick.dao&quot;/&gt;
    &lt;/mappers&gt;


&lt;/configuration&gt;
</code></pre>
<hr>
<h2 id="项目源码点鸡这里">项目源码：<a href="https://github.com/ArtZoick/MyBatis">点鸡这里</a></h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MyBatis_1	简介]]></title>
        <id>https://ArtZoick.github.io//post/MyBatis_1</id>
        <link href="https://ArtZoick.github.io//post/MyBatis_1">
        </link>
        <updated>2019-07-03T14:06:19.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-什么是框架">1、什么是框架？</h2>
<p>它是我们软件开发中的一套解决方案，不同的框架解决的是不同的问题<br>
使用框架的好处：<br>
框架封装了很多的细节，使开发者可以使用极简的方式实现功能。大大提高开发效率。</p>
<h2 id="2-三层架构">2、三层架构</h2>
<p><strong>表现层：</strong><br>
是用于展示数据的<br>
<strong>业务层：</strong><br>
是处理业务需求<br>
<strong>持久层：</strong><br>
是和数据库交互的</p>
<h2 id="3-持久层技术解决方案">3、持久层技术解决方案</h2>
<p><strong>JDBC技术：</strong><br>
Connection<br>
PreparedStatement<br>
ResultSet<br>
<strong>Spring的JdbcTemplate：</strong><br>
Spring中对jdbc的简单封装<br>
<strong>Apache的DBUtils：</strong><br>
它和Spring的JdbcTemplate很像，也是对Jdbc的简单封装<br>
以上这些都不是框架<br>
JDBC是规范</p>
<p>Spring的JdbcTemplate和Apache的DBUtils都只是工具类</p>
<h2 id="4-mybatis的概述">4、mybatis的概述</h2>
<p>mybatis是一个持久层框架，用java编写的。<br>
它封装了jdbc操作的很多细节，使开发者只需要关注sql语句本身，而无需关注注册驱动，创建连接等繁杂过程。<br>
它使用了ORM思想实现了结果集的封装。</p>
<p><strong>ORM：</strong><br>
Object Relational Mappging 对象关系映射<br>
简单的说：就是把数据库表和实体类及实体类的属性对应起来，让我们可以操作实体类就实现操作数据库表。<br>
user					User<br>
id						userId<br>
user_name	userName</p>
<p>我们需要做到<br>
<em>实体类中的属性和数据库表的字段名称保持一致。</em></p>
<h2 id="5-mybatis的入门">5、mybatis的入门</h2>
<h3 id="表的创建与数据的插入">表的创建与数据的插入</h3>
<p><img src="https://ArtZoick.github.io//post-images/mybatis/0_1.png" alt=""></p>
<p><img src="https://ArtZoick.github.io//post-images/mybatis/0_2.png" alt=""></p>
<h3 id="mybatis环境搭建demo的基本架构">mybatis环境搭建demo的基本架构</h3>
<p><img src="https://ArtZoick.github.io//post-images/mybatis/1.png" alt=""></p>
<p><strong>第一步：创建maven工程并导入坐标</strong></p>
<p><strong>第二步：创建实体类和dao的接口</strong></p>
<p><strong>第三步：创建Mybatis的主配置文件</strong></p>
<p><em>SqlMapConifg.xml</em></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;!-- mybatis主配置文件--&gt;
&lt;configuration&gt;
    &lt;!-- 配置环境--&gt;
    &lt;environments default=&quot;mysql&quot;&gt;
        &lt;!-- 配置mysql的环境--&gt;
        &lt;environment id=&quot;mysql&quot;&gt;
            &lt;!-- 配置事务的类型--&gt;
            &lt;transactionManager type=&quot;jdbc&quot;&gt;&lt;/transactionManager&gt;
            &lt;!-- 配置数据源（连接池）--&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;!-- 配置链接数据库的四个基本信息--&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/eesy_mybatis&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;

    &lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件--&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;top/zoick/dao/IUserDao.xml&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<p><strong>第四步：创建映射配置文件</strong></p>
<p><em>IUserDao.xml</em></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;mapper namespace=&quot;top.zoick.dao.IUserDao&quot;&gt;
    &lt;!--配置查询所有  其中id不能乱写必须是dao接口中的方法  resultType写的是实体类的全路径--&gt;
    &lt;select id=&quot;findAll&quot; resultType=&quot;top.zoick.domain.User&quot;&gt;
        select * from user
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="环境搭建的注意事项">环境搭建的注意事项：</h3>
<p><strong>第一个：</strong> 创建IUserDao.xml 和 IUserDao.java时名称是为了和我们之前的知识保持一致。<br>
在Mybatis中它把持久层的操作接口名称和映射文件也叫做：Mapper<br>
所以：IUserDao 和 IUserMapper是一样的<br>
<strong>第二个：</strong> 在idea中创建目录的时候，它和包是不一样的<br>
包 <em>（Package）</em> 在创建时：com.itheima.dao它是三级结构<br>
目录 <em>（Directory）</em> 在创建时：com.itheima.dao是一级目录<br>
<strong>第三个：</strong> mybatis的映射配置文件位置必须和dao接口的包结构相同<br>
<strong>第四个：</strong> 映射配置文件的mapper标签namespace属性的取值必须是dao接口的全限定类名<br>
<strong>第五个：</strong> 映射配置文件的操作配置（select），id属性的取值必须是dao接口的方法名</p>
<p>当我们遵从了第三，四，五点之后，我们在开发中就无须再写dao的实现类。</p>
<h3 id="mybatis的入门案例">mybatis的入门案例</h3>
<p><strong>第一步：</strong> 读取配置文件<br>
<strong>第二步：</strong> 创建SqlSessionFactory工厂<br>
<strong>第三步：</strong> 创建SqlSession<br>
<strong>第四步：</strong> 创建Dao接口的代理对象<br>
<strong>第五步：</strong> 执行dao中的方法<br>
<strong>第六步：</strong> 释放资源</p>
<p><strong>注意事项：</strong><br>
不要忘记在映射配置中告知mybatis要封装到哪个实体类中<br>
配置的方式：指定实体类的全限定类名</p>
<p><strong>mybatis基于注解的入门案例：</strong><br>
把IUserDao.xml移除，在dao接口的方法上使用@Select注解，并且指定SQL语句<br>
同时需要在SqlMapConfig.xml中的mapper配置时，使用class属性指定dao接口的全限定类名。<br>
<strong>明确：</strong><br>
我们在实际开发中，都是越简便越好，所以都是采用不写dao实现类的方式。<br>
不管使用XML还是注解配置。</p>
<p>但是Mybatis它是支持写dao实现类的。</p>
<h2 id="6-自定义mybatis的分析__执行查询所有的分析">6、自定义Mybatis的分析__执行查询所有的分析</h2>
<p>mybatis在使用代理dao的方式实现增删改查时做什么事呢？<br>
只有两件事：<br>
第一：创建代理对象<br>
第二：在代理对象中调用selectList</p>
<p>自定义mybatis能通过入门案例看到类<br>
class　　　　Resources　　使用类加载器读取配置文件的类<br>
class　　　　SqlSessionFactoryBuilder　　用于创建一个SqlsessionFactory对象<br>
interface　　SqlSessionFactory　　用于打开一个新的SqlSession<br>
interface　　SqlSession　　自定义MYbatis中和数据库交互的核心类</p>
<p><img src="https://ArtZoick.github.io//post-images/mybatis/2.png" alt=""></p>
<p>自定义mybatis开发流程图:</p>
<p><img src="https://ArtZoick.github.io//post-images/mybatis/2_2.png" alt=""></p>
<p>Project结构：</p>
<p><img src="https://ArtZoick.github.io//post-images/mybatis/2_1.png" alt=""></p>
<p>1.读取配置文件用io包里的Resources<br>
2.读出所需要的信息交给SqlSessionFactoryBuilder构建者<br>
3.构建者使用工具类XMLConfigBuilder构建出DefaultSqlsessionFactory工厂对象，xml读取的信息保存在Configuration里<br>
4.工厂里的openSession提供了Sqlsession方法<br>
5.再在SqlSession里实现创建代理对象和查询所有的功能</p>
<p>测试类</p>
<pre><code class="language-java">package top.zoick.test;


import top.zoick.dao.IUserDao;
import top.zoick.domain.User;
import top.zoick.mybatis.io.Resources;
import top.zoick.mybatis.sqlsession.SqlSession;
import top.zoick.mybatis.sqlsession.SqlSessionFactory;
import top.zoick.mybatis.sqlsession.SqlSessionFactoryBuilder;

import java.io.IOException;
import java.io.InputStream;
import java.util.List;

/**
 * @author zoick
 * @date 2019/7/4 21:27
 * mybatis的入门案例
 */
public class MybatisTest {
    public static void main(String[] args) throws IOException {
        //1.读取配置文件
        InputStream in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);
        //2.创建SqlSessionFactory工厂
        SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
        SqlSessionFactory factory = builder.build(in);
        //3.使用工厂生产SqlSession对象
        SqlSession session = factory.openSession();
        //4.使用SqlSession创建Dao接口的代理对象
        IUserDao userDao = session.getMapper(IUserDao.class);
        //5.使用代理对象执行方法
        List&lt;User&gt; users = userDao.findAll();
        for (User user: users) {
            System.out.println(user);
        }
        //6.释放资源
        session.close();
        in.close();
    }
}
</code></pre>
<hr>
<h2 id="项目源码点鸡这里">项目源码：<a href="https://github.com/ArtZoick/MyBatis">点鸡这里</a></h2>
]]></content>
    </entry>
</feed>